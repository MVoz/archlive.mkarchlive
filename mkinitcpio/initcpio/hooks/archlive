#args: source, mountpoint
_mnt_bind()
{
    info "将 ${addon_dir}/${1} 挂载到 real_root${2}"
    mkdir -p /real_root${2}
    /bin/mount -o bind ${1} /real_root${2}
}

# args: image file
_mnt_squashfs()
{
    img="${1}"
    base_img="/tmp/$(/usr/bin/basename ${img})";
    #mnt="${2}"

    info "挂载镜像${base_img} 到根文件系统/real_root"
    /bin/modprobe -q loop max_loop=255 >/dev/null 2>&1

    if [ "${copy2ram}" = "y" ]; then
        info "拷贝${img}到内存"
        mkdir -p /tmp
        mount -t tmpfs -o "size=6M" tmpfs /tmp
        /bin/cat ${img} > "${base_img}"
        img="${base_img}"
    fi

    mkdir -p "/tmpfs/mnt/loop${LOOP_NUM}"
    while [ ! -e "/dev/loop${LOOP_NUM}" ]; do
        sleep 1
    done
    if ! /bin/losetup "/dev/loop${LOOP_NUM}" ${img} > /dev/null 2>&1; then
        error "错误: 无法挂载loop设备 /dev/loop${LOOP_NUM}"
        break
    fi
    /bin/mount -r -t squashfs "/dev/loop${LOOP_NUM}" "/tmpfs/mnt/loop${LOOP_NUM}"

    /bin/mount -t aufs -o remount,add:1:/tmpfs/mnt/loop${LOOP_NUM}=rr aufs "/real_root"
    export LOOP_NUM=$(( $LOOP_NUM + 1 ))
}

mount_tmpfs () 
{
    #if [ "x${ramdisk_size}" = "x" ]; then
        ramdisk_size="15M"
    #fi
    info -n "挂载临时文件系统tmpfs, 大小${ramdisk_size}... "
    mount -t tmpfs -o "size=${ramdisk_size}" tmpfs /tmpfs
    hl "完成."; echo
}

device_mountdir()
{
   echo "/tmpfs/mnt/$(/usr/bin/basename "$1")" # | tr -s /
}

search_cd()
{
    info "扫描光盘设备...: "    
    /bin/modprobe -q isofs >/dev/null 2>&1
    /bin/modprobe -q udf >/dev/null 2>&1

    cdroms=/dev/$( /bin/cat /proc/sys/dev/cdrom/info | { while read a b c; do
                if [ "${a}" = "drive" -a "${b}" = "name:" ]; then
                    echo "${c}"
                    break
                fi
            done
        } )
     
    for cdrom in ${cdroms} /dev/sr[0-9]* /dev/hd[a-z] /dev/scd[a-z] /dev/sg[0-9]*; do
    	[ ! -e "${cdrom}" ] && continue
        bootcdmnt="$(device_mountdir ${cdrom})"
        /bin/mkdir -p "${bootcdmnt}"
    	 if mount -r -t iso9660 "${cdrom}" "${bootcdmnt}" >/dev/null 2>&1 ||\
          mount -r -t udf "${cdrom}" "${bootcdmnt}" >/dev/null 2>&1; then
             if [ "x${from}" != "x" ]; then
                    #from=$(/usr/bin/basename ${from})
                if [ -f "${bootcdmnt}/${from}/archlive.sqfs" ]; then
                        found=1
                        hl "在${cdrom}/${from}下找到基本模块archlive.sqfs"; echo
                        BOOT_MOUNT="${bootcdmnt}"
			export datadir=${cdrom}/${from}
                        break
                fi
             else
                if [ -f "${bootcdmnt}/archlive.sqfs" ]; then
                        found=1
                        hl "在${cdrom}下找到基本模块archlive.sqfs"; echo
                        BOOT_MOUNT="${bootcdmnt}"
			export datadir=${cdrom}
                        break
                fi
             fi
        else
            hl "uhm"; echo
            error "无法挂载 ${cdrom}"
        fi
        [ ${found} -eq 0 ] && umount "${bootcdmnt}" >/dev/null 2>&1
    done
}

search_usb()
{
    info "扫描本地硬盘或者USB盘(U盘或者移动硬盘)... "
    info "检测USB设备，请稍候..."
    /sbin/udevadm trigger --subsystem-match=usb
    /sbin/udevadm settle
    usbdelay=$(( ${usbdelay:-0} + 1 ))
    info -n "请等 ${usbdelay}s 以设置USB设备"
    /bin/sleep "${usbdelay}"

    for usb in /dev/[s,h]d[a-z][0-9]; do
       [ ! -e "${usb}" ] && continue
       bootusbmnt="$(device_mountdir ${usb})"
       /bin/mkdir -p "${bootusbmnt}"
       if mount -t vfat "${usb}" "${bootusbmnt}" >/dev/null 2>&1 ||\
	   ntfs-3g -o utf8 "${usb}" "${bootusbmnt}" >/dev/null 2>&1 ||\
	   mount -t reiserfs "${usb}" "${bootusbmnt}" >/dev/null 2>&1 ||\
	   mount -t ext2 "${usb}" "${bootusbmnt}" >/dev/null 2>&1 ||\
	   mount -t ext3 "${usb}" "${bootusbmnt}" >/dev/null 2>&1 ||\
	   mount -t ext4 "${usb}" "${bootusbmnt}" >/dev/null 2>&1 ||\
	   mount -t xfs "${usb}" "${bootusbmnt}" >/dev/null 2>&1 ||\
         mount -t btrfs "${usb}" "${bootusbmnt}" >/dev/null 2>&1; then
         if [ "x${from}" != "x" ]; then
             #from=$(/usr/bin/basename ${from})
             if [ -f "${bootusbmnt}/${from}/archlive.sqfs" ]; then
                   found=1
                   info "在${usb}/${from}下找到基本模块archlive.sqfs"; echo
                   BOOT_MOUNT="${bootusbmnt}"
		   export datadir=${usb}/${from}
                   break
             fi
         else
             if [ -f "${bootusbmnt}/archlive.sqfs" ]; then
                   found=1
                   hl "在${usb}下找到基本模块archlive.sqfs"; echo
                   BOOT_MOUNT="${bootusbmnt}"
		   export datadir=${usb}
                   break
                    fi
             fi
         else
             error "无法挂载 ${usb}"
         fi
         [ ${found} -eq 0 ] && umount "${bootusbmnt}" >/dev/null 2>&1
    done
}

run_hook ()
{
    export LOOP_NUM="0"
    mount_tmpfs
    found=0

     # 如果内核启动参数有bootusb或者boothd则从USB或者硬盘设备上查找，如果有bootcd则从光盘设备上查找；
     # 如果没有指定启动介质，则先从光盘查找，再从USB或者硬盘设备上超找
    if [ "${bootusb}" = "y" -o "${boothd}" = "y" ] ; then
	    search_usb
    elif [ "${bootcd}" = "y" ]; then 
		search_cd 
    else 
	    search_cd
          if [ ${found} -eq 0 ]; then search_usb; fi
    fi

    if [ ${found} -eq 0 ]; then
        error "错误: 没有找到archlive的基本模块，无法继续..."
        error "   返回到命令行界面模式"
        PS1="ramfs$ " /bin/sh -i
        exit 1
    fi

    # 调试用测试点
    if [ "${break}" = "y" ]; then
        echo ":: 被要求暂停, 输入'exit'继续"
        echo "   注意: klibc不包含ls命令, 但archlive内核镜像加入了ls命令"
        PS1="ramfs$ " /bin/sh -i
    fi

    /bin/modprobe -q squashfs >/dev/null 2>&1
    /bin/modprobe -q sqlzma >/dev/null 2>&1
    /bin/modprobe -q unlzma >/dev/null 2>&1
    /bin/modprobe -q aufs brs=1 >/dev/null 2>&1
    XINO=xino
    MEMORY=memory
    if [ "$XINO" != "$MEMORY" ]; then
    	/bin/mkdir -p $XINO
    	/bin/mount -n -t tmpfs tmpfs $XINO
    fi
    
    /bin/mount -t aufs -o nowarn_perm,xino=$XINO/.aufs.xino,br:/tmpfs=rw aufs /real_root

    if [ "x${from}" != "x" ]; then
        _mnt_squashfs "${BOOT_MOUNT}/${from}/archlive.sqfs"
    else
    	_mnt_squashfs "${BOOT_MOUNT}/archlive.sqfs"
    fi

    echo "aufs / aufs defaults 0 0" > /real_root/etc/fstab
    /bin/mount -o move ${BOOT_MOUNT} /real_root/mnt/$(/usr/bin/basename ${BOOT_MOUNT})

    # 调试用测试点
    if [ "${break}" = "y" ]; then
        echo ":: 被要求暂停, 输入'exit'继续"
        echo "   注意: klibc不包含ls命令, 但archlive内核镜像加入了ls命令"
        PS1="ramfs$ " /bin/sh -i
    fi
		
    ROOT=/real_root
    cp -Rf /lib/modules/* /real_root/lib/modules/
    /bin/mkdir -p $ROOT/dev 2>&1 >/dev/null
    #/bin/mknod $ROOT/dev/console c 5 1 2>&1 >/dev/null
    #/bin/mknod $ROOT/dev/null c 1 3 2>&1 >/dev/null
    #/bin/mknod $ROOT/dev/zero c 1 5 2>&1 >/dev/null

    udevpid=$(/bin/minips -C udevd -o pid=)
    [ "x${udevpid}" != "x" ] && /bin/kill -9 $udevpid 2>&1 >/dev/null

    /bin/umount /sys
    /bin/umount /proc
    info "现在启动基本模块archlive.sqfs"
    info "-----------------------------------------------------------------------------"
    exec /bin/run-init -c /dev/console /real_root /sbin/init
}