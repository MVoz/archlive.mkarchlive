#!/bin/sh

RST="\033[1;0m"

# regular colors
K="\033[0;30m"    # black
R="\033[0;31m"    # red
G="\033[0;32m"    # green
Y="\033[0;33m"    # yellow
B="\033[0;34m"    # blue
M="\033[0;35m"    # magenta
C="\033[0;36m"    # cyan
W="\033[0;37m"    # white

# emphasized (bolded) colors
EMK="\033[1;30m"
EMR="\033[1;31m"
EMG="\033[1;32m"
EMY="\033[1;33m"
EMB="\033[1;34m"
EMM="\033[1;35m"
EMC="\033[1;36m"
EMW="\033[1;37m"

# background colors
BGK="\033[40m"
BGR="\033[41m"
BGG="\033[42m"
BGY="\033[43m"
BGB="\033[44m"
BGM="\033[45m"
BGC="\033[46m"
BGW="\033[47m"

hl () { echo -n "${W}$@${RST}";  }
hg () { echo "${EMG}$@${RST}"; }
hy () { echo "${EMY}$@${RST}"; }
hr () { echo "${EMR}$@${RST}"; }

info () {
    if [ $# -eq 2 ] && [ "$1" = "-n" ]; then
        echo -n " $EMB*$RST "; hl "$2"
    else
        echo -n " $EMB*$RST "; hl "$@"; echo
    fi
}

msg () {
    info $@;
}

error () {
    if [ $# -eq 2 ] && [ "$1" = "-n" ]; then
        echo -n " $EMR*$RST "; hl "$2"
    else
        echo -n " $EMR*$RST "; hl "$@"; echo
    fi
}

warn () {
    if [ $# -eq 2 ] && [ "$1" = "-n" ]; then
        echo -n " $EMY*$RST "; hl "$2"
    else
        echo -n " $EMY*$RST "; hl "$@"; echo
    fi
}

echo
hg "                   Welcome to Archlive ! 欢迎使用 Archlive !"
hl "*******************************************************************************"
echo
echo  "${EMY}  Archlive${RST}, ${EMG}live system ${RST}base on ${EMY}Arch GNU/Linux${RST}."
echo  "${EMY}  Archlive${RST}, 基于${EMY}Arch GNU/Linux${RST}的${EMG}live系统${RST}."
echo 
hr "  此系统基于GNU通用发布协议(GPL)发行"
hr "  Distributed under the GNU General Public License (GPL)"  
hl "*******************************************************************************"
echo

/bin/mount -t sysfs none /sys
/bin/mount -t proc  none /proc

# Suppressing all printk
echo "0" > /proc/sys/kernel/printk

read CMDLINE </proc/cmdline
export CMDLINE

# Used so hooks can override params to kinit
export kinit_params=""
export root=""
echo "/sbin/modprobe" > /proc/sys/kernel/modprobe

# Checking boot paremeters 检查启动参数
for cmd in ${CMDLINE}; do
    case "${cmd}" in
        \#*) break ;; # ignore everything after a # in the commandline
        [0123456Ss]) export runlevel="${cmd}" ;;
        single) export runlevel="S" ;; #some people use 'single'
        #Allow "init=X" to pass-through
        init=*) kinit_params="${kinit_params} ${cmd}" ;;
        # only export stuff that does work with dash :)
        *=*) cmd="$(replace -s= "${cmd}" '.' '_')"
             cmd="$(replace -s= "${cmd}" '-' '_')"
             export "${cmd}"
             ;;
        *)   cmd="$(replace "${cmd}" '.' '_')"
             cmd="$(replace "${cmd}" '-' '_')"
             export "${cmd}=y" 
           ;;
    esac
done

if [ "$cn" = "y" ]; then
	msg "现在开始启动 ..."
else
	msg "Now start to boot ..."
fi

if [ -n "${disablehooks}" ]; then
    for d in $(replace "${disablehooks}" ','); do
        export "hook_${d}=disabled"
    done
fi

# Special for plymouth
[ "$splash" != "y" ] && export "hook_plymouth=disabled"

if [ -n "${disablemodules}" ]; then
    for d in $(replace "${disablemodules}" ','); do
        export "mod_${d}=disabled"
    done
fi

if [ -n "${earlymodules}" ]; then
    for m in $(replace "${earlymodules}" ','); do
        /sbin/modprobe -q ${m} > /dev/null 2>&1
    done
fi

. /config

for m in ${MODULES}; do
    TST=""
    eval "TST=\$mod_${m}"
    if [ "${TST}" != "disabled" ]; then
        /sbin/modprobe -q ${m} > /dev/null 2>&1
    fi
done

if [ -e "/hooks" ]; then
    for h in ${HOOKS}; do
        TST=""
        eval "TST=\$hook_${h}"
        if [ "${TST}" != "disabled" ]; then
            run_hook () { info "${h}: no run function defined"; }
            if [ -e "/hooks/${h}" ]; then
               . /hooks/${h}
               info "运行启动脚本 $EMW[$G${h}$EMW]"
               run_hook
            fi
        fi
    done
fi

if [ "${rootdelay}" != "0" ]; then
    info -n "正在检测设备，稍候..."

    /bin/sleep "${rootdelay}"

    export rootdelay=0
    export kinit_params="$kinit_params rootdelay=0"

    hl "完成."
    echo
fi

if [ "${break}" = "y" ]; then
	if [ "$cn" = "y" ]; then
		echo ":: 被要求暂停, 输入'exit'继续"
	else
		echo ":: Break requested, type 'exit' to resume operation"
	fi
    PS1="ramfs$ " /bin/sh -i
fi

if [ ! -b "${root}" ]; then
    # This duplicates code from the filesystem hook
    # without this, mkinitcpio would fail for users who use
    # neither the udev hook, nor the filesystem hook
    
    echo
    warn "设备'${root}' 不存在, 尝试创建"

    eval $(/bin/parseblock "${root}")
    if [ "${BLOCKNAME}" = "unknown" ]; then
        error "ERROR: Failed to parse block device name for '${root}'"
    elif [ -z "${BLOCKDEVICE}" ]; then
        error "ERROR: Failed to parse block device ids for '${root}'"
    else
        export root="${BLOCKNAME}"
        echo "/bin/mknod \"${BLOCKNAME}\" b ${BLOCKDEVICE}"
        /bin/mknod "${BLOCKNAME}" b ${BLOCKDEVICE} >/dev/null
    fi
    if [ ! -b "${root}" ]; then
        error "Unable to create/detect root device '${root}'"
        
        warn "Dropping to a recovery shell... type 'exit' to reboot"
        warn "NOTE: klibc contains no 'ls' binary, use 'echo *' instead"
        echo ""
        warn "If the device '${root}' gets created while you are here,"
        warn "try adding 'rootdelay=8' or higher to the kernel command-line"
        PS1="ramfs$ " /bin/sh -i
        info "重新启动..."
        /bin/reboot
        fi
fi


if [ -f "/message" ]; then
    msg "$(cat /message)"
fi

if [ "$cn" = "y" ]; then
	msg ":: 内核镜像加载完成 - 开始kinit启动进程"
else
	msg ":: Initramfs Completed - control passing to kinit"
fi

#Special handling if udev is running
udevpid=$(/bin/minips -C udevd -o pid=)
if [ -n "${udevpid}" ]; then
    /bin/kill -9 ${udevpid} 2>/dev/null 1>/dev/null
    /bin/sleep 0.01
fi

exec /bin/kinit -- "root=${root}" ${kinit_params} "${runlevel}" > /dev/null 2>&1
