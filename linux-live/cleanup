#!/bin/ash
# Initial script for Linux Live operating system
# Author: Tomas M <http://www.linux-live.org/>

export PATH=.:/:/usr/sbin:/usr/bin:/sbin:/bin

mount -n -t proc proc /proc
mount -n -t sysfs sysfs /sys
#mount -n -o remount,rw /         # for the case we forgot rw boot option
ln -sf /proc/mounts /etc/mtab    # this allows us to use umount -a

. liblinuxlive # it requires proc to be mounted

# Don't print kernel messages to konsole now.
# Syslog will reset printk settings, no need to remember it here anymore.
echo "0" >/proc/sys/kernel/printk

# Load essential drivers, like CDROM drivers, aufs/squashfs etc,
# use mdev to create /dev/ devices and setup it as a hotplug-handler
modprobe_essential_modules

# 挂载基本模块中压缩模块usr.lzm dev.lzm
mount_initrd_loops

# 初始化硬件
mdev_start_hotplug

# 初始化USB、PCMCIA等模块
modprobe_usb_modules
modprobe_pcmcia_modules

debug_shell

# make sure ext3 partitions are not mounted using ext2 driver,
# and vfat partitions are not mounted using msdos driver
echo -e "ext3\next2\nvfat\n*" >/etc/filesystems

mkdir -p $UNION
mkdir -p $MEMORY

debug_shell

# 内核可以通过sgn=...来定义搜索标的，该文件同一目录下的文件夹即为模块文件夹
SGN=$(cmdline_value sgn)
if [ "$SGN" = "" ]; then SGN=archlive.list; fi
echolog "搜索$LIVECDNAME基本模块(根据$SGN定位)"

# 在启动参数中加入datafrom 或者 ip可以加快查找数据文件夹base
DATAFROM=$(cmdline_value datafrom)

# 如果ip=[] 参数出现，则优先PXE启动
# ip=<client-ip>:<boot-server-ip>:<gw-ip>:<netmask>
# ip 和 datafrom两个参数中，优先使用datafrom
#
IP=$(cmdline_value ip)
if [ "$IP" != "" -a "$DATAFROM" = "" ]; then
   DATAFROM="http://"$(echo $IP | cut -d : -f 2)
fi

if [ "$DATAFROM" = "" -a "$IP" = "" ]; then
	DATAFROM=$(cmdline_value from)
fi

# datadir由内核启动脚本赋值，为基本模块archlive.sqfs的位置
# 如果在archlive.sqfs同一级文件夹下有base文件夹，则从此调用并启动
# 将 $datadir 中的/dev/换为挂载路径
DATADIR=$(echo $datadir | sed -r "s:^/dev/:/$MOUNTDIR/:")
if [ -f $DATADIR/$SGN ] && [ -d $DATADIR/base ]; then
	DATA=$DATADIR
fi

if [ "$DATAFROM" ]; then
   if [ "$(echo $DATAFROM | cut -b 1-7 | tr "[:upper:]" "[:lower:]")" = "http://" ]; then
      init_dhcp $(modprobe_network_modules)
      mount_httpfs $DATAFROM $MOUNTDIR/httpfs
      # if mountdir/httpfs/livecdname is found, set DATA=, else umount httpfs
      # - currently this part works even without the above mentioned, but archlive.sqfs is required now untill it's uncommented
   else
      DATAFROM=$(find_in_computer $DATAFROM)
      if [ "$DATAFROM" ]; then
         mount_device $DATAFROM $LOOPMOUNT # mount again, it may be loop device
         if [ $? -eq 0 -a "$(find_modules $LOOPMOUNT/$LIVECDNAME)" != "" ]; then
            echolog "在$DATAFROM找到模块文件夹"
            DATA=$LOOPMOUNT/$LIVECDNAME
         else
            fumount $LOOPMOUNT
            fumount $MOUNTDIR/*
         fi
      fi
   fi
fi

if [ "$DATA" = "" ]; then
   # from= is not used or it didn't contain valid data
   DATA=$(find_in_computer $LIVECDNAME/$SGN)
   DATA=$(dirname $DATA 2>/dev/null)
fi

if [ "$DATA" = "" ]; then fatal \
"没有找到 $LIVECDNAME 的程序模块.
可能使用了不被支持的启动设备(比如 SCSI或者老的PCMCIA).
解决办法: 将$LIVECDNAME目录从你的启动设备拷贝到IDE/SATA盘，比如拷贝到
/mnt/hda1/$LIVECDNAME 或者 C:\\$LIVECDNAME. 然后重新启动."
fi

echolog "从$DATA 启动 $LIVECDNAME"

debug_shell

echolog "设置$changes保存修改..."
CHANGESVAL=$(cmdline_value changes)

if [ "$CHANGESVAL" ]; then
   CHANGESMNT=$(find_in_computer $CHANGESVAL)
   echolog $CHANGESMNT
fi

debug_shell

mount_device "$CHANGESMNT" $MEMORY # removes $MEMORY if CHANGESMNT is wrong

# 检测指定的changes是否可写
touch $MEMORY/empty 2>/dev/null && \
rm -f $MEMORY/empty 2>/dev/null

# 如果changes无法被正确挂载或者其不可写，则用默认的tmpfs
if [ $? -ne 0 ]; then
   echolog "启动参数无changes=XXX，或者设置的目标不可用或者不可写，使用内存存储，重启将丢失修改的内容"
   fumount $MEMORY
   mkdir -p $MEMORY # mount_device might removed it

   RAMSIZE=$(cmdline_value ramsize)
   if [ "$RAMSIZE" = "" ]; then RAMSIZE="60%"; fi
   mount -t tmpfs -o "size=$RAMSIZE" tmpfs $MEMORY
   XINO=$MEMORY
else
   # So it is writable, we will keep the filesystem mounted.
   # Check if it supports links and chmod.
   # If not, overmount CHANGES using posixovl
   echolog "检测文件系统的posix兼容性 ..."
   touch $MEMORY/.empty1 && \
   ln -sf $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null && \
   chmod +x $MEMORY/.empty1 2>/dev/null  && \
   test -x $MEMORY/.empty1 && \
   chmod -x $MEMORY/.empty1 2>/dev/null  && \
   test ! -x $MEMORY/.empty1 && \
   rm $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null

   if [ $? -ne 0 ]; then
      echolog "不兼容 - 开启 posiovl"
      rm $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null
      mkdir -p $CHANGES
      posixovl -F $CHANGES -- -o attr_timeout=300,entry_timeout=300,negative_timeout=300,kernel_cache,allow_other
      find $CHANGES >/dev/null 2>&1 # cache everything now
   fi
fi

# $UNION 将被作为root系统, 模块都将挂载在此目录
echolog "设置$UNION目录 (使用aufs)"

mkdir -p $CHANGES
mkdir -p $IMAGES

debug_shell

# 将xino文件存储在内存, 更快速、安全
if [ "$XINO" != "$MEMORY" ]; then
   mkdir -p $XINO
   mount -n -t tmpfs tmpfs $XINO
fi

# mount aufs using the writable branch as the first one (leftmost/topmost)
mount -t aufs -o nowarn_perm,xino=$XINO/.aufs.xino,br:$CHANGES=rw aufs $UNION
if [ $? -ne 0 ]; then dmesg | tail -n 1; fatal "can't setup union (aufs)"; fi

debug_shell

# If toram or copy2ram boot parameter is present, copy all fs modules to RAM.
# (skip modules from /optional/ which are not listed in load= boot option)
# Finaly modify DATA variable so it will point to correct directory
if [ "$(cmdline_parameter toram)" != "" -o "$(cmdline_parameter copy2ram)" != "" ]; then
   echolog "拷贝$LIVECDNAME数据到内存，请稍候..."
   mkdir -p $COPY2RAM

   # make sure it's in RAM even with changes= parameter
   if [ "$CHANGESMNT" ]; then mount -t tmpfs -o "size=$RAMSIZE" tmpfs $COPY2RAM; fi
   copy_to_ram $DATA $COPY2RAM

   cd_autoeject 1
   fumount $DATA
   fumount $MOUNTDIR/*
   rmdir $MOUNTDIR/* 2>/dev/null # mounted device names are empty, remove them
   DATA=$COPY2RAM
   cd_autoeject 0
fi

debug_shell

# DATA包含archlive里面的base目录，模块目录，可选模块目录
# 现在挂载到aufs文件系统中
echolog "装载模块:"
union_insert_modules $UNION $DATA $IMAGES

    # 调试用测试点
    if [ "${break}" = "y" ]; then
        echo ":: 被要求暂停, 输入'exit'继续"
        echo "   注意: klibc不包含ls命令, 但archlive内核镜像加入了ls命令"
        PS1="ramfs$ " /bin/sh -i
    fi

# the $MEMORY directory can contain $MEMORY/modules too
# in the case if changes= boot argument is used. If not, it doesn't hurt
# 挂载保存修改的文件系统
union_insert_modules $UNION $MEMORY $IMAGES

    # 调试用测试点
    if [ "${break}" = "y" ]; then
        echo ":: 被要求暂停, 输入'exit'继续"
        echo "   注意: klibc不包含ls命令, 但archlive内核镜像加入了ls命令"
        PS1="ramfs$ " /bin/sh -i
    fi

debug_shell

if [ $(cmdline_parameter norootcopy) ]; then
	echolog "启动参数无rootcopy"
else
	echolog "将rootcopy内容拷贝到$UNION"
	cp -af $DATA/rootcopy/* $UNION 2>/dev/null # may be empty
fi

# TODO: if copy2ram is used, there is no need to preserve the original in memory anymore
#if [ "$DATA" = "$COPY2RAM" ]; then 
#    rm from memory once ??
#fi

echolog "拷贝liblinuxlive库到$UNION/usr/lib/"
cp -af /liblinuxlive $UNION/usr/lib/

debug_shell

echolog "更新 /etc/fstab 和硬盘分区挂载目录/mnt/... "
touch $UNION/etc/fstab
rmdir $UNION/mnt/* 2>/dev/null
fstab_update $UNION
#fstab_clean $UNION

# everything is ready now, so we may unload unused kernel modules
# and do some cleanup, unmount few things which are no longer needed.
#rmmod_unused_modules
fumount /usr
fumount /sys

# More likely these directories aren't there.
# Even if they are, this won't hurt.
mkdir -p $UNION/boot
mkdir -p $UNION/proc
mkdir -p $UNION/sys
mkdir -p $UNION/dev
mkdir -p $UNION/tmp
chmod 1777 $UNION/tmp

# Boot will contain whatever was in ./boot directory in the bootable media
# Error output goes to null, as nothing is mounted with copy2ram
#mount -n -o rbind $(dirname $DATA)/boot $UNION/boot 2>/dev/null

debug_shell

# This is for setup of locale varible in archlive
lang=$(cmdline_value lang)
if [ "$lang" ]; then
	if [ -f "$UNION/etc/rc.conf" ]; then
		sed -i -e "s/^ *\(LOCALE=\).*$/\1"$lang.utf8"/" $UNION/etc/rc.conf
		touch $UNION/etc/locale.gen
		echo "$lang.UTF-8 UTF-8" > $UNION/etc/locale.gen
		echo "$lang ISO-8859-1" >> $UNION/etc/locale.gen
	fi
fi

debug_shell

# Union contains all the files and directories unioned from all modules.
# Change root directory to it, and move initrd's root to /mnt/live/initramdisk
# Finaly execute /sbin/init to start the distribution.
echolog "切换root目录到$UNION..."

cd $UNION
mkdir -p $INITRAMDISK

# Copy all dev files (found by mdev) to unioned dev directory
# so at least disk devices exist (your Linux may need them).
# Two exceptions, do not copy pty* and tty* devs.
if [ ! -e /dev/console ]; then mknod /dev/console c 5 1; fi
cp -fdR /dev . 2>/dev/null

# find chroot and init
if [ -x bin/chroot ]; then  CHROOT=bin/chroot; fi
if [ -x sbin/chroot ]; then  CHROOT=sbin/chroot; fi
if [ -x usr/bin/chroot ]; then  CHROOT=usr/bin/chroot; fi
if [ -x usr/sbin/chroot ]; then CHROOT=usr/sbin/chroot; fi
if [ "$CHROOT" = "" ]; then fatal "没有找到chroot命令"; fi

if [ -x bin/init ]; then INIT=bin/init; fi
if [ -x sbin/init ]; then INIT=sbin/init; fi
if [ "$INIT" = "" ]; then fatal "没有找到init命令"; fi

# time to end Linux Live scripts and start the distribution itself,
# using /sbin/init or whatever was found.

debug_shell

mount -n -o remount,ro aufs .

# We will copy init from the distro to initrd (there should be 2MB free)
# This allows us to use the cleanup script during reboot, as init will be
# started from memory and not from the union and /union will not be busy.

cp -af $INIT /bin
if [ $? -eq 0 ]; then
   pivot_root . $INITRAMDISK
   exec $CHROOT . $INITRAMDISK/bin/init <dev/console >dev/console 2>&1
else # If copying fails, start init directly.
   pivot_root . $INITRAMDISK
   exec $CHROOT . $INIT <dev/console >dev/console 2>&1
fi

header "!!错误!!"
fatal "如果你看到本消息，之前的步骤一定有错误!"