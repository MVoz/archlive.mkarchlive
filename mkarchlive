#!/bin/bash
#########################################################################################
# 本脚本属于 archlive 项目一部分  作者  Carbon Jiao  (Email:  carbonjiao alt gmail dot com)
# 详情 http://archlive.googlecode.com http://archlive-pkg.googlecode.com
#
# 本工具可以在任何符合条件的linux系统上构建基于Arch GNU/Linux包管理系统pacman的live系统——
# 可以是桌面环境、专业服务器甚至是防火墙。mkarchlive给你充分定制机会。
#
# mkarchlive 可以运行于符合如下条件的linux系统中：
# A、目标镜像类型为iso时，宿主系统需要安装3.72以上版本的syslinux;
# B、宿主系统需要安装如下常用软件: cdrkit(mkisofs) wget tar links shell
#   sed grep gawk module-init-tools(depmod) util-linux-ng(mount)  glibc(ldconfig) findutils(find)
#   coreutils(ls, cut, tr, echo, rm, mkdir, cp, cat, chown, chmod, head, mknod, tee, touch, ln, md5sum)
#
# 支持i686 x86_64的目标系统创建, 理论上还支持mips，只要有对应软件仓
# （i686平台可以创建x86_64 Archlive, 反之亦然）
#
# 制作iso镜像时，无论使用什么bootloader，宿主系统都需要syslinux中的isohybrid程序来产生iso的md5sum
#
# 支持全方位定制： 定制启动脚本、定制目标系统软件、定制软件仓、预配置文件。。。
#########################################################################################
#
# 2009-09-22 修改目标系统内核版本判断方式，加快速度。普通用户可以使用 -h 来获取帮助
# 2009-09-14 加入检测宿主系统是否存在必须命令的判断
# 2009-09-07 独立hg repo， 使脚本独立运行
# 2009-09-04 优化更新。
# 2009-08-25 加入pacman.static 在非Arch环境下也可运行本脚本制作基于Arch GNU/Linux的Live系统。
# 2009-08-24 加入ARCH选项，在i686环境下可以制作x86_64的live系统，反之亦然。
# 2009-08-23 加入附加模块独立制作的支持，加入grub2的支持
# 2009-08-22 加入判断 archlive.conf的模块可以采用加#来去掉，简化更新创建archlive的步骤
# 2009-08-21 加入查找archlive.conf配置文件的文件夹层数限制
# 2009-08-13 检误，并智能化检测、判断制作配置文件archlive.conf
# 2009-08-12 将是否采用overlay个性化定制目录设置放于archlive.conf中
# 2009-08-10 修改运行目录结构，并将模块压缩方式的选择放到配置文件中
# 2009-08-10 修改判断软件仓是否已经在pacman.conf中定义的判断方式
#
APPNAME=$(basename "${0}")
cmdline=$@

# 消息提示风格, 默认 无颜色输出
if [ -f profiles/archlive/archlive.conf ]; then
	NO_COLOR=$(grep "NO_COLOR" profiles/archlive/archlive.conf | awk -F "\"" '{print $2}')
fi
if [ "${NO_COLOR}" != "n" ]; then
	NO_COLOR="y"
else
	NO_COLOR="n"
fi
plain() { 
	if [ "${NO_COLOR}" != "y" ]; then 
		echo -e "\033[1;2m  \033[1;0m     $@\033[1;0m"
	else
		echo "     $@"
	fi
}
msg() {
	if [ "${NO_COLOR}" != "y" ]; then 
		echo -e "\033[1;32m==>\033[1;0m\033[1;1m $@\033[1;0m"
	else
		echo "==> $@"
	fi
}
msg2() {
	if [ "${NO_COLOR}" != "y" ]; then 
		echo -e "\033[1;34m   ->\033[1;0m\033[1;1m $@\033[1;0m"
	else
		echo "  -> $@"
	fi
}
warn() {
	if [ "${NO_COLOR}" != "y" ]; then 
		echo -e "\033[1;33m==> $(gettext "WARNING:")\033[1;0m\033[1;1m $@\033[1;0m"
	else
		echo " !!! $(gettext "WARNING:") $@"
	fi
}
error() {
	if [ "${NO_COLOR}" != "y" ]; then 
		echo -e  "\033[1;31m==> $(gettext "ERROR:")\033[1;0m\033[1;1m $@\033[1;0m"
	else
		echo " xxx $(gettext "ERROR:") $@"
	fi
}
green() {
	if [ "${NO_COLOR}" != "y" ]; then
		echo -e "\033[1;32m $@\033[1;0m"
	else
		echo " * $@"
	fi
}
# usage: usage <exitvalue>
usage ()
{
   green " 本制作程序须用管理员身份或者sudo来执行，须要aufs文件系统的支持，同时有cdrkit等软件"
   green " 如果强制使用pacman.static，需确保宿主系统含有如下程序："
   green " cdrkit(mkisofs) wget tar links shell sed grep gawk module-init-tools(depmod)"
   green " util-linux-ng(mount) glibc(ldconfig) findutils(find) "
   green " coreutils(ls, cut, tr, echo, rm, mkdir, cp, cat, chown, chmod, head, mknod, tee, touch, sort, ln, md5sum)"
   green " 以上程序中，括号里面的是本脚本调用的命令，确保宿主系统包含这些命令! "
   green " 请确保archlive制作配置文件archlive.conf存放位置与archlive.conf中指定的PROFILE_DIR一致"
   green " 注意：输入的选项及命令定义的参数优先性高于配置文件." 
   echo ""
   green " 用法：${APPNAME} [选项] 命令 <命令选项>"
   green " 一般选项:"
   echo "    -f               强制覆盖现有的工作目录等，全部重新制作"
   echo "    -i CPIO_CONFIG   用CONFIG 作为archlive启动内核配置文件. "
   echo "    -c CDNAME        目标镜像名. 默认: archlive"
   echo -e "    -b BOOT	     启动选项(syslinux,isolinux,grub,grub-gfx, grub2 \
	 \n		     默认配置文件中没有提供grub2的菜单文件)"
   echo "    -M MODULES       livecd的模块. "
   echo "    -m MODULESCOPY   从指定的文件夹拷贝附加模块，比如程序模块等. 默认: 无"
   echo "    -a ADDON_DIR     从指定文件夹制作附加设置模块. 默认: 无"
   echo "    -t <iso,img>     目标镜像类型. 默认iso."
   echo "    -v               运行输出结果."
   echo "    -h               本帮助信息."
   green " 命令:"
   echo -e "     prepare                   : 准备iso根目录结构及overlay(如果选择需要overlay，\
	 \n			          在archlive.conf中配置)"
   echo "     modules <工作目录>        : 仅在工作目录下制作独立程序模块, 程序清单在archlive.conf中配置"
   echo "     install [工作目录]        : 将程序安装到工作目录下"
   echo "     squash <工作目录>         : 从指定的目录创建squash模块"
   echo "     bootimage <工作目录>      : 从指定的目录制作archlive启动内核镜像."
   echo "     core_module <工作目录>    : 创建archlive基本模块到工作目录下指定位置."
   echo "     img <工作目录> <目标镜像> : 从指定目录创建目标镜像"
   echo "     all <工作目录> <目标镜像> : 顺序执行以上所有命令"
   exit $1
}

case "$cmdline" in *-h*) usage 1;; esac
[ "$EUID" != "0" ] && (error "错误: 必须以root用户运行本制作脚本." && exit 1)

green "  *************************************************************************"
green "				运行本程序前： "
green "  *** 请详细阅读readme, archlive.conf等文件——了解详细的操作过程后继续 ***"
green "	 			5 秒后继续"
green "  *************************************************************************"
echo ""
sleep 5

# 挂载aufs文件系统并判断是否已经挂载成功
modprobe aufs
[ $? -ne 0 ] && (error "无法装载aufs文件系统模块,请确保宿主系统aufs内核模块被正确安装. " && exit 1)
rmmod aufs
###------------------------检测配置---------------------------------------

# 检测宿主系统是否包含本脚本调用的命令
need_cmd="wget tar links sed grep gawk depmod mount ldconfig find ls cut tr echo rm mkdir cp cat chown chmod head mknod tee sort touch ln md5sum"
host_cmd_dir=$(echo $PATH | tr ":" "\n")
[ -f /tmp/cmd_list ] && rm -f /tmp/cmd_list
for dir in ${host_cmd_dir}; do
   if [ -d $dir ]; then 
	ls -1 $dir >>/tmp/cmd_list
   fi
done
for cmd in ${need_cmd}; do
   if [ "x$(grep "$cmd" /tmp/cmd_list)" = "x" ]; then
	error "宿主系统不存在(或者在系统PATH指定的路径下不存在)必须的命令$cmd"
	error "请安装后再运行本制作脚本..."
	usage 1
   fi
done

# 根据配置文件archlive.conf存放位置与archlive.conf中PROFILE_DIR定义的值是否一致来判断查找到的配置文件是否是正确
config_is_right () {
   case "${CONFIG_FILE}" in "./${PROFILE_DIR}/archlive.conf") return 0;; esac
   return 1
}
# 装载archlive的配置文件, 从当前目录查看是否存在archlive.conf，存在即调用之
msg "开始检测 程序相关配置设置 "

#echo "查找配置文件archlive.conf，以第一个符合条件的为制作配置文件"
for config_file in $(find .  -name "archlive.conf"); do
	source ${config_file}
	if [ ! $(config_is_right) ]; then CONFIG_FILE=${config_file} && break; fi
done
if [ "x${CONFIG_FILE}" = "x" ]; then
   error "没有找到正确的配置文件archlive.conf" && usage 1 
#else
#   plain "载入archlive制作配置文件${CONFIG_FILE}"
fi
source ${CONFIG_FILE}
if [ "x${PROFILE_DIR}" = "x" ]; then
	error "载入配置文件${CONFIG_FILE}失败，请检查配置文件是否已经损坏..."
#else
#	plain "完成."
fi

# 检测、配置输入的命令
while getopts 'i:P:b:M:m:a:t:c:nfvh' arg; do
   case "${arg}" in
	i) CPIOCONFIG="${OPTARG}" ;;
	b) BOOT="${OPTARG}" ;;
	M) MODULES="${OPTARG}" ;;
	m) MODULESCOPY="${OPTARG}" ;;
	a) ADDON_DIR="${OPTARG}" ;;
	t) IMG_TYPE="${OPTARG}" ;;
	c) CDNAME="${OPTARG}" ;;
	f) FORCE="y" ;;
	v) QUIET="n" ;;
        h|?) usage 0 ;;
        *) error "无效参数 '${arg}'"; usage 1 ;;
   esac
done

#plain "输入的选项及命令: $cmdline"
shift $(($OPTIND - 1))

CMD_NAME="${1}"
case "${CMD_NAME}" in
   prepare) DESCRIPTION="准备工作: 准备安装程序，准备镜像目录结构，Overlay目录等.";;
   modules) WORK_DIR="${2}"; RE_EXTRAMODULES="y"; DESCRIPTION="在工作目录${WORK_DIR}下制作独立程序模块：安装后用mksquash压缩." ;;
   install) WORK_DIR="${2}"; RE_EXTRAMODULES="n" ; DESCRIPTION="将程序清单或者附加模块指定的程序安装到工作目录${WORK_DIR}." ;;
   squash) WORK_DIR="${2}"; RE_EXTRAMODULES="n"; DESCRIPTION="将工作目录${WORK_DIR}中的程序用mksquash压缩为模块." ;;
   core_module) WORK_DIR="${2}"; DESCRIPTION="创建archlive基本模块到工作目录${WORK_DIR}下指定位置." ;;
   bootimage) WORK_DIR="${2}"; DESCRIPTION="从指定的目录${WORK_DIR}制作archlive启动内核模块及基本模块等" ;;
   img) WORK_DIR="${2}"; IMGNAME="${3}"; DESCRIPTION="将工作目录${WORK_DIR}对应目录制作为iso或者img镜像." ;;
   all) WORK_DIR="${2}"; IMGNAME="${3}"; DESCRIPTION="根据配置文件或者参数指定的设置制作程序模块并打包为启动镜像." ;;
   *) warn "无效命令 '${CMD_NAME}'"; usage 1 ;;
esac

#START_DIR=$(pwd)
START_DIR=.
PROFILE_DIR="${START_DIR}/${PROFILE_DIR}"
MKINITCPIO="${START_DIR}/mkinitcpio/mkinitcpio"
REPO_ADD="${START_DIR}/lib/repo-add"

# 如果archlive.conf没有定义则采用如下默认配置

# 包含内核的模块, 如果archlive.conf中没有定义则默认为list中的第一个
if [ "x${KERNEL_MOD}" = "x" ]; then
   KERNEL_MOD="$(ls -1 ${PROFILE_DIR}/$LISTDIR | head -1)"
fi
if [ "x$QUIET" = "x" ]; then QUIET="y"; fi
if [ "x$FORCE" = "x" ]; then FORCE="y"; fi
if [ "x$CDNAME" = "x" ]; then CDNAME="archlive"; fi
if [ "x$CACHE" = "x" ]; then
   if [ -f /etc/pacman.conf ]; then
	CACHE="$(grep "CacheDir" /etc/pacman.conf | awk -F '=' '{print $2}')"
   else
	plain "系统不存在pacman.conf，宿主系统不是Arch, 将创建软件包缓存位置/var/cache/pacman/pkg"
	CACHE="/var/cache/pacman/pkg"
   fi
fi
if [ "x$PUBLISHER" = "x" ]; then PUBLISHER="http://archlive.googlecode.com/"; fi
if [ "x$AUTHOR" = "x" ]; then AUTHOR="Carbon Jiao"; fi
if [ "x$IMG_TYPE" = "x" ]; then IMG_TYPE="iso"; fi

# 检测模块压缩模式
case ${ZIP_MODE} in 
   1) MKSQUASHFS="${START_DIR}/squashfs3/mksquashfs"
      EXT="sqfs"
      OPTION="-nolzma"
      #modprobe squashfs
      [ $? -ne 0 ] && error "宿主系统无squashfs3 文件系统模块" && usage 1
      ;;
   2) MKSQUASHFS="${START_DIR}/squashfs3/mksquashfs"
      EXT="lzm"
      OPTION=""
      #modprobe sqlzma
      [ $? -ne 0 ] && error "宿主系统无打lzm补丁的squashfs文件系统模块" && usage 1
      ;;
   3) MKSQUASHFS="${START_DIR}/squashfs4/mksquashfs"
      EXT="sqfs"
      OPTION=""
      #modprobe squashfs
      [ $? -ne 0 ] && error "宿主系统无squashfs4文件系统模块" && usage 1
      ;;
esac

# 装载archlive软件仓等相关配置
if [ "x${PACMANCONF}" = "x" ]; then
   PACMANCONF="${PROFILE_DIR}/pacman_${ARCH}.conf"
fi
# 更新安装时候的软件缓存位置
sed -i "s%.*CacheDir.*%CacheDir = $CACHE%g" $PACMANCONF

# 目标镜像启动内核镜像配置文件
if [ "x${CPIOCONFIG}" = "x" ]; then
   CPIOCONFIG="${PROFILE_DIR}/archlive-mkinitcpio.conf"
fi

case $IMG_TYPE in
	iso*) IMG_TYPE="iso" ;;
	img*) IMG_TYPE="img" ;;
	disk*) IMG_TYPE="img" ;;
	cd*) IMG_TYPE="iso" ;;
	*) IMG_TYPE="iso"; warn "无效的目标类型，采用默认的iso";;
esac
case $BOOT in
	isolinux) BOOT="isolinux" ;;
	syslinux) BOOT="syslinux" ;;
	grub2) BOOT="gub2" ;;
	grub*) BOOT="grub" ;;
	*) BOOT="isolinux"; warn "未知的或者暂时不支持的目标镜像引导程序，采用默认的isolinux" ;;
esac

if [ "x${BOOT}" = "x" ]; then BOOT="syslinux"; fi

if [ "x${WORK_DIR}" = "x" ]; then
#   plain "命令行没有指定工作目录，查看配置文件中是否有设置的工作目录"
   WORK_DIR=$(grep WORK_DIR ${CONFIG_FILE} | cut -d "=" -f2)
   if [ "x${WORK_DIR}" = "x" ]; then 
	WORK_DIR="/$(date +%m%d)"
	#warn "配置文件也没有指定工作目录，采用默认设置${WORK_DIR}"
   fi
fi
[ -d ${WORK_DIR} ] && mkdir -p ${WORK_DIR}
if [ "x${IMGNAME}" = "x" ]; then IMGNAME="${WORK_DIR}/archlive-${ARCH}-$(date +%F).iso"; fi

#archlive最终软件清单
PKGFILE="${WORK_DIR}/packages.list"

#实际需要的模块 (去掉#)
MODULES=$(echo $MODULES | tr -s " " "\n" | grep -v "#")
EXTRAMODULES=$(echo $EXTRAMODULES | tr -s " " "\n" | grep -v "#")

case $cmdline in *-f*) FORCE="y";; esac
###---------------------------程序运行相关目录设置--------------------------------
# 制作的Archlive镜像目录（该文件夹下所有内容全部包含于目标镜像）
IMGROOT="${WORK_DIR}/${ARCH}_img"

# 制作Archlive的aufs文件系统挂载点
UNION="${WORK_DIR}/union"

# 制作的Archlive的模块实际存放目录（安装的实际位置）
MODULEDIR="${WORK_DIR}/${ARCH}_modules"

# archlive.conf中定义的EXTRAMODULES的安装位置
EXTRA_MODULES_INS_DIR="${MODULEDIR}/extra_modules"

# 附加独立程序模块EXTRAMODULES的存放位置（sqfs或者lzm模块）
EXTRA_MODULES_TARGET="${IMGROOT}/${CDNAME}/modules/extra_modules"

# 不需要的模块备份位置
NO_NEED_MODULES_DIR="${WORK_DIR}/${NO_NEED_MODULES}"

# archlive.conf 中定义的 EXTRAPACKAGEDIR 的存放位置
EXTRA_PACKAGE_TARGET="${IMGROOT}/${CDNAME}/modules/extra_package"

# 内核模块的安装位置   比如 ${WORK_DIR}/modules/0_000_core  制作启动内核镜像需要此变量
INSTROOT="${MODULEDIR}/$(basename ${KERNEL_MOD} .list)"

# 模块软件清单（包含版本信息）目录
PACKLIST="${WORK_DIR}/list"
# .new  存放目前对应模块最新软件清单（需要安装的）
# .old  存放运行本脚本前对应模块的软件清单
# .list 存放对应模块更新详情
# mod_模块.new 为最终 对应模块的实际软件清单

# 附加模块清单（最终，包含版本信息）
EX_MODULE_LIST=${PACKLIST}/extra_module.list

# 模块安装日志存放目录
BUILDLOG="${WORK_DIR}/log"
# 该目录下
# -current.log 为目前正进行操作的日志
#  -errors.log 为对应模块安装错误日志

# 宿主系统可用执行程序
HOST_CMD="${WORK_DIR}/host_cmd_list"

#--------检查宿主系统程序是否满足条件----
case ${IMG_TYPE} in iso)
	mkisofs_version=$(mkisofs --version | head -1| cut -d " " -f2)
	[ "x${mkisofs_version}" = "x" ] && (error "宿主系统没有mkisofs程序，请先安装cdrkit" && exit 1)
	;;
esac
squashfs_version=$($MKSQUASHFS -version | head -1 | cut -d " " -f3)

# 判断宿主系统是否是Arch
ARCH_HOST="n"
# 将宿主系统可用执行程序排序输出到工作目录下
sort /tmp/cmd_list > ${HOST_CMD}
if [ -d /var/lib/pacman/local ]; then
	case $(cat ${HOST_CMD}) in *makepkg*pacman*) ARCH_HOST="y" ;; esac
fi
if [ "${ARCH_HOST}" = "n" ]; then
	if [ "${USE_STATIC_PACMAN}" != "y" ]; then
		error "宿主系统不是Arch，请在${CONFIG_FILE}中设置USE_STATIC_PACMAN=y"
		exit 1
	fi
else
	host_pacman_version=$(pacman -V | grep "Pacman" | head -1 | tr -s " " | cut -d " " -f4)
fi
	
	
#--------------------------------------

green "----------------- *** ${APPNAME} 程序设置结果： *** --------------------------"
echo " 宿主系统是否是Arch GNU/Linux:  ${ARCH_HOST} "
echo "       ${APPNAME}程序执行操作:  ${CMD_NAME}"
echo "         Archlive定制配置文件:  ${CONFIG_FILE}"
echo "                     目标系统:  ${ARCH}"
echo "                     工作目录:  ${WORK_DIR}"
if [ "${CMD_NAME}" = "prepare" -o "${CMD_NAME}" = "install" -o "${CMD_NAME}" = "all" ]; then
echo "       目标镜像源文件存放目录:  ${IMGROOT} "
fi
if [ "${CMD_NAME}" = "install" -o "${CMD_NAME}" = "all" ]; then
echo "               软件包缓存目录:  ${CACHE} "
fi
echo "              pacman.conf文件: ${PACMANCONF}"
if [ "${CMD_NAME}" = "img" -o "${CMD_NAME}" = "all" ]; then
echo "                 目标镜像类型:  ${IMG_TYPE}"
echo "                     标镜像名:  ${IMGNAME}"
echo "                     启动程序:  ${BOOT}"
fi
if [ "${CMD_NAME}" = "squash" -o "${CMD_NAME}" = "modules" -o "${CMD_NAME}" = "all" ]; then
echo "                     模块类型:  ${EXT}"
fi
if [ "${CMD_NAME}" = "bootimage" -o "${CMD_NAME}" = "all" ]; then
echo " Archlive启动内核镜像配置文件:  ${CPIOCONFIG}"
fi
if [ "${CMD_NAME}" = "core_module" -o "${CMD_NAME}" = "all" ]; then
echo "           基本核心模块存放到:  ${IMGROOT}/${CDNAME}/archlive.sqfs"
fi
if [ "${CMD_NAME}" = "bootimage" -o "${CMD_NAME}" = "all" ]; then
echo "           包含内核程序的模块:  ${KERNEL_MOD}"
fi
if [ "${CMD_NAME}" = "install" -o "${CMD_NAME}" = "all" ]; then
echo "                     是否覆盖：  ${FORCE}"
fi
if [ "${CMD_NAME}" = "install" -o "${CMD_NAME}" = "squash" -o "${CMD_NAME}" = "all" ]; then
echo " 需要制作的模块为: $(echo ${MODULES} | tr -s "\n" " ")"
fi
if [ "${CMD_NAME}" = "install" -o "${CMD_NAME}" = "squash" -o "${CMD_NAME}" = "modules" -o "${CMD_NAME}" = "all" ]; then
echo "  需要制作的附加独立程序模块为: $(echo ${EXTRAMODULES} | tr -s "\n" " ")"
fi
echo ""
plain " 执行的动作： ${DESCRIPTION}"
green "-----------------------------------------------------------------------------------"
green "*** 如果以上设置不是你想要的设置，Ctrl+C 终止程序的执行，并检测相关配置文件. ***"
echo "                        5 秒后开始程序"
sleep 5
echo ""
msg "现在开始执行 ${APPNAME} ${CMD_NAME}"

###--------------------程序、函数、模块----------------------------------------
# 自定义软件仓
# $1 预建立软件仓的位置
# $2 预建立的软件仓的名称
function custom_repo () 
{
   for pkgfile in $(ls $1/*.pkg.tar.gz); do
   	sh ${REPO_ADD} $1/$2.db.tar.gz $pkgfile
    done
    rm -rf $1/$2.db.tar.gz.old
}
function is_in_pacmanconf () 
{
   a=$(cat ${PACMANCONF} | sed -r "s/#.*//")
   case $a in 
	*[${REPO_Name}]*) case $a in *file://$REPO*) return 0;; esac
	;;
	esac
   return 1
}

# 将自定义的软件仓加入到PACMANCONF中，默认第一优先
# pacman.conf须是在# and they will be used before the default mirrors.行后开始定义软件仓.
function add_customrepo2pacmanconf ()
{
   sed -i "/# and they will be used before the default mirrors./ a\
	\ \n[${REPO_Name}]\
	\nServer = file://$REPO" ${PACMANCONF}
   plain "将自定义软件仓加入${PACMANCONF}完成"
}

prepare_overlay (){

   msg2 "准备Archlive 系统配置文件目录overlay"
   [ -d ${WORK_DIR}/overlay ] && rm -rf ${WORK_DIR}/overlay
   if [ -d ${PROFILE_DIR}/overlay ]; then
	mkdir -p ${WORK_DIR}/overlay
	cp -rf ${PROFILE_DIR}/overlay/* ${WORK_DIR}/overlay/
   else
      if [ ! -f overlay.tgz ]; then
		plain "下载Archlive附加配置文件overlay.tgz"
		wget -q "${TGZURL}/overlay.tgz"  2>&1 > /dev/null
      fi
      plain "释放Archlive附加配置文件overlay.tgz"
      tar -xzvpf overlay.tgz -C ${WORK_DIR}   2>&1 > /dev/null
   fi
   OVERLAY=${WORK_DIR}/overlay
   for theme in ${THEME}; do 
   	if [ ! -f "${theme}-theme.tgz" ]; then
		plain "下载主题包文件${theme}-theme.tgz"
            	wget -q "${TGZURL}/${theme}-theme.tgz"  2>&1 > /dev/null
       	fi
	[ ! -d ${OVERLAY}/usr/share/themes ] && mkdir -p ${OVERLAY}/usr/share/themes
	plain "释放主题包${theme}-theme.tgz"
       	tar -xzvpf "${theme}-theme.tgz" -C "${OVERLAY}/usr/share/themes/"   2>&1 > /dev/null
   done
   for icon in ${ICON}; do 
   	if [ ! -f "${icon}-icons.tgz" ]; then
		plain "下载图标文件${icon}-icons.tgz"
	  	wget -q "${TGZURL}/${icon}-icons.tgz"  2>&1 > /dev/null
       	fi
	[ ! -d ${OVERLAY}/usr/share/icons ] && mkdir -p ${OVERLAY}/usr/share/icons
	plain "释放图标文件包${icon}-icons.tgz"
       	tar -xzvpf "${icon}-icons.tgz" -C "${OVERLAY}/usr/share/icons/"  2>&1 > /dev/null
   done
   for cursor in ${CURSOR}; do 
    	if [ ! -f "${cursor}-cursor.tgz" ]; then
   		plain "下载鼠标指针文件包${cursor}-cursor.tgz"
       		wget -q "${TGZURL}/${cursor}-cursor.tgz"  2>&1 > /dev/null
	fi
	[ ! -d ${OVERLAY}/usr/share/icons ] && mkdir -p ${OVERLAY}/usr/share/icons
 	plain "释放鼠标指针文件包${cursor}-cursor.tgz"
	tar -xzvpf "${cursor}-cursor.tgz" -C "${OVERLAY}/usr/share/icons/"  2>&1 > /dev/null
   done
   for font in ${EXTRAFONTS}; do 
   	if [ ! -f "${font}-font.tgz" ]; then
		plain "下载附加字体包文件${font}-font.tgz"
        	wget -q "${TGZURL}/${font}-font.tgz"  2>&1 > /dev/null
       	fi
	[ ! -d ${OVERLAY}/usr/share/fonts/TTF ] && mkdir -p ${OVERLAY}/usr/share/fonts/TTF
	plain "释放附加字体包${font}-font.tgz"
       	tar -xzvpf "${font}-font.tgz" -C "${OVERLAY}/usr/share/fonts/TTF/"  2>&1 > /dev/null
   done
   [ -d "${OVERLAY}/home/arch" ] && chown -R 1001:100 "${OVERLAY}/home/arch" && chmod -R 700 "${OVERLAY}/home/arch"
   [ -d ${OVERLAY}/root ] && chown -R root:root "${OVERLAY}/root" && chmod -R 700 "${OVERLAY}/root"

   msg2 "overlay准备完毕"
}
prepare_pacman (){

   # 检查宿主系统是否存在pacman，如果不存在则下载pacman.static以完成后续操作
   # 如果archlive.conf强制使用静态编译版pacman，则下载pacman.static

   msg2 "准备安装程序 pacman / pacman.static "
   PACMAN="pacman"
   if [ "${USE_STATIC_PACMAN}" = "y" -o "x${host_pacman_version}" = "x" ]; then
	[ "${USE_STATIC_PACMAN}" = "y" ] && plain "配置文件${CONFIG_FILE} 设置为强制使用pacman.static"
	[ "x${pacman_version}" = "x" ] && plain "宿主系统不是Arch GNU/Linux, 使用pacman.static代替"
	if [ -x /tmp/usr/bin/pacman.static ]; then
		PACMAN="/tmp/usr/bin/pacman.static"
		pacman_version=$(${PACMAN} -V | grep "Pacman" | head -1 | tr -s " " | cut -d " " -f 4)
		[ "x${pacman_version}" = "x" ] && rm -f /tmp/usr/bin/pacman.static
	fi
	if [ ! -x /tmp/usr/bin/pacman.static ]; then 
		PKGARG="http://repo.archlinux.fr/${ARCH}"
		#PKGARG="http://repo.archlinux-br.org/${ARCH}"
		if [ ! -f pacman-static-*.pkg.tar.gz ]; then
			plain "现在开始下载pacman.static ..."
			wget -c $PKGARG/$(links -dump $PKGARG | grep "pacman-static-" | cut -d " " -f 1) 2>&1 > /dev/null
		else
			plain "使用$(ls pacman-static-*.pkg.tar.gz)"
		fi
		tar -xzvpf pacman-static*.pkg.tar.gz -C /tmp 2>&1 > /dev/null
		[ -x /tmp/usr/bin/pacman.static ] && PACMAN="/tmp/usr/bin/pacman.static"
		pacman_version=$(${PACMAN} -V | grep "Pacman" | head -1 | tr -s " " | cut -d " " -f 4)
		[ "x${pacman_version}" = "x" ] && error "无法找到pacman.static程序，请确认下载的包是否完整!" && usage 1
	fi
   fi
   [ "x${pacman_version}" != "x" ] && msg2 "完成! 安装程序为 $PACMAN, 版本为: ${pacman_version}"
}
cmd_prepare (){

   # 检查是否是升级安装
   if [ "${CMD_NAME}" = "install" ] && [ -d ${WORK_DIR} ]; then
	if [ "x$(find ${WORK_DIR} -type f -name "desc" | grep var/lib/pacman/local)" != "x" ]; then
		if [ "${FORCE}" = "n" ]; then
			error "错误: 工作目录'${WORK_DIR}'中已经安装过软件包, 退出."
			error "      加入 -f 参数或者archlive.conf中设置FORCE="y"来升级安装. "
			exit 1
		else
			green "更新archlive——基于${WORK_DIR}来更新制作archlive."
		fi
   	fi
   fi
   msg "开始准备工作..."
   prepare_pacman
   msg2 "创建制作archlive的相关目录"
   [ ! -d ${UNION} ] && mkdir -p "${UNION}"    # {WORK_DIR} 一并被创建
   [ ! -d ${INSTROOT} ] && mkdir -p "${INSTROOT}"
   [ ! -d ${MODULEDIR} ] && mkdir -p "${MODULEDIR}"

   if [  "x$REPO_Name" != "x" -a "x$REPO" != "x" ]; then
       msg2 "建立自定义软件仓..."
       custom_repo ${REPO} ${REPO_Name}
       msg2 "自定义软件仓建立完成"
       if ! is_in_pacmanconf; then add_customrepo2pacmanconf; fi
   fi

   msg2 "准备目标镜像根目录结构及启动的相关配置文件"
   [ ! -d ${IMGROOT} ] && mkdir -p ${IMGROOT}
   if [ -d ${PROFILE_DIR}/cd-root ]; then
	cp -rf ${PROFILE_DIR}/cd-root/* ${IMGROOT}/
   else
      if [ ! -f cd-root.tgz ]; then
		plain "下载Archlive光盘根目录结构文件cd-root.tgz"
		wget -q "${TGZURL}/cd-root.tgz"  2>&1 > /dev/null
      fi
      echo "释放Archlive光盘根目录结构cd-root.tgz"
      tar -xzvpf cd-root.tgz -C ${IMGROOT}  2>&1 > /dev/null
   fi
   mkdir -p ${IMGROOT}/${CDNAME}/{base,modules,optional,rootcopy}
   msg2 "完成."

   if [ "${USE_OVERLAY}" = "y" ]; then
	prepare_overlay
   fi

   # 删除下载的 tgz文件
   [ "$DELETE_TGZ" = "y" ] && rm -f ${START_DIR}/*.tgz

   # 软件安装日志文件夹
   [ -d ${BUILDLOG} ] && rm -R ${BUILDLOG}
   mkdir -p ${BUILDLOG}

   msg "mkarchlive准备工作完成"
}
function mount_aufs_w () {
   plain "将$1以aufs可写模式挂载到${UNION}"
   mount -t aufs -o br:$1=rw aufs ${UNION}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs可写模式挂载到${UNION}."
        usage 1
   else
	green "完成."
   fi
}
function remount_aufs_w () {
   plain "将$1以aufs可写模式挂载到${UNION}"
   mount -o remount,add:0:$1=rw aufs ${UNION}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs可写模式挂载到${UNION}."
        usage 1
   else
	green "完成."
   fi
}
function remount_aufs_r () {
   plain "将$1以aufs只读模式挂载到${UNION}"
   [ -f ${UNION}/var/lib/pacman/db.lck ] && rm -f ${UNION}/var/lib/pacman/db.lck
   [ -d ${UNION}/dev ] && rm -rf ${UNION}/dev
   mount -o remount,mod:$1=ro aufs ${UNION}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs只读模式挂载到${UNION}."
        usage 1
   else
	green "完成."
   fi
}

function sync_database () {

   # Arch软件仓数据库存放位置
   SYNC="${WORK_DIR}/sync"
   msg2 "将Arch软件仓库信息更新到${SYNC} ..."
   [ ! -d ${SYNC} ] && mkdir -p "${SYNC}"
   mount_aufs_w "${SYNC}"
   [ ! -d ${UNION}/var/lib/pacman ] && mkdir -p ${UNION}/var/lib/pacman
   [ -f ${UNION}/var/lib/pacman/db.lck ] && rm -f ${UNION}/var/lib/pacman/db.lck
   plain "现在开始更新软件仓..."
   $PACMAN -Sy --noprogressbar --noconfirm --config "${PACMANCONF}" -fr "${UNION}"
   remount_aufs_r "${SYNC}"
   msg2 "Arch软件仓库信息更新完成。"
   plain "导出可用软件包清单到${PACKLIST}/available.list"
   find "${SYNC}/var/lib/pacman/sync" -type d -name "*" | sed -r "s|${SYNC}/var/lib/pacman/sync||g" >${PACKLIST}/available.list
   green "完成."
}
function pac_install () {

   [ ! -d $UNION/dev ] && mkdir -p $UNION/dev
   [ ! -c $UNION/dev/console ] && mknod $UNION/dev/console c 5 1 >/dev/null
   [ ! -c $UNION/dev/null ] && mknod $UNION/dev/null c 1 3 >/dev/null
   [ ! -c $UNION/dev/zero ] && mknod $UNION/dev/zero c 1 5 >/dev/null

   while true; do
	$PACMAN -S -f $pkgname --needed --noconfirm --config "${PACMANCONF}" \
			-r "$UNION"  2>&1 | tee -a ${BUILDLOG}/${mod}-current.log
	if [ $? -ne 0 ]; then
		if [ "x$(grep $pkgname ${PACKLIST}/available.list)" != "x" ]; then
			error "安装$pkgname出错"
			cat ${BUILDLOG}/${mod}-current.log >> ${BUILDLOG}/${mod}-errors.log
			break
		else
			if [ $(echo $pkgname | grep "-") ]; then
				error "现有软件仓中无 $pkgname, 去掉 -* 后再查找"
				pkgname=${pkgname%-*}
			else
				error "现有软件仓中无 $pkgname, 忽略"
			fi
		fi
	else
		#green "软件包${pkgname} 安装成功! "
		break
	fi
   done
}

function pac_remove () {

   while true; do
	$PACMAN -R -d -n --noprogressbar --needed --noconfirm --config "${PACMANCONF}" \
		-r "$UNION" $pkgname  2>&1 | tee -a ${BUILDLOG}/${mod}-current.log
	if [ $? -ne 0 ]; then
		if [ "x$(ls $UNION/var/lib/pacman/local | grep $pkgname)" != "x" ]; then
			error "卸载$pkgname出错"
			cat ${BUILDLOG}/${mod}-current.log >> ${BUILDLOG}/${mod}-errors.log
			break
		else
			error "$pkgname 还没有安装，无法卸载。"
		fi
	else
		green "软件包${pkgname} 卸载成功! "
		break
	fi
   done	
}

function pac_clean () {

   msg2 "清理无用文件..."

   plain "清理aufs文件系统临时文件.wh.* "
   for tmp in "$(find ${MODULEDIR} -type f -name .wh.* )"; do [ "x$tmp" != "x" ] && rm -f $tmp; done
   green "完成!"

   plain "删除为宿主系统创建的内核镜像文件..."
   default_image=$(grep "default_image" ${INSTROOT}/etc/mkinitcpio.d/kernel*.preset | cut -d "=" -f2)
   fallback_image=$(grep "fallback_image" ${INSTROOT}/etc/mkinitcpio.d/kernel*.preset | cut -d "=" -f2)
   [ "x${default_image}" != "x" ] && rm -f "${INSTROOT}${default_image}"
   [ "x${fallback_image}" != "x" ] && rm -f "${INSTROOT}${fallback_image}"
   green "完成!"

   plain "删除pamcan产生的垃圾文件..."
   for tmp in "$(find ${MODULEDIR} -name *.pacnew -name *.pacsave -name *.pacorig)"; do [ "x$tmp" != "x" ] && rm -f $tmp; done
   green "完成!"

   plain "删除指定的文件夹..."
   kill_dirs="dev var/cache/man var/cache/pacman var/log/* var/mail tmp/* initrd ${DELDIR}"
   #for tmp in ${kill_dirs}; do [ -e "${UNION}/${x}" ] && rm -rf "${UNION}/${tmp}"; done
   for tmp in ${kill_dirs}; do
	for tmp_dir in $(find ${MODULEDIR} -type d -name "$(basename $tmp)" | grep "$tmp");do
		[ "x${tmp_dir}" != "x" ] && rm -rf ${tmp_dir}
	done
   done
   green "完成!"

   plain "删除图标缓存文件..."
   for tmp in "$(find ${MODULEDIR} -type f -name *.cache)"; do [ "x$tmp" != "x" ] && rm -f $tmp; done
   green "完成!"

   if [ "${CUT_LOCALE}" = "y" ]; then
	plain "删除${REMAIN_LOCALE}外的语言文件、帮助文件、X语言文件..."
	for tmpdir in $(find ${MODULEDIR} -type d -name "locale"); do
		for tmp in "$(find $tmpdir/* -maxdepth 0 -type d | grep -v "[${REMAIN_LOCALE}]$")"; do
			[ "x$tmp" != "x" ] && rm -rf $tmp
		done
	done
   	green "完成!"
   fi
}

cmd_extramodules_install () {

   msg2 "开始制作附加程序模块——每个模块只有一个软件"

   # 初始化附加模块安装目录
   [ -d ${EXTRA_MODULES_INS_DIR} ] && rm -rf ${EXTRA_MODULES_INS_DIR} && mkdir -p ${EXTRA_MODULES_INS_DIR}
   # 如果只是独立制作模块需要单独更新软件仓库信息
   [ "${CMD_NAME}" = "modules" ] && sync_database
   [ -f ${EX_MODULE_LIST} ] && rm -f ${EX_MODULE_LIST}
   for mod in $EXTRAMODULES; do
	[ ! -d ${EXTRA_MODULES_INS_DIR}/${mod} ] && mkdir -p ${EXTRA_MODULES_INS_DIR}/${mod}
	remount_aufs_w ${EXTRA_MODULES_INS_DIR}/${mod}
	[ "x$mod" = "x" ] && continue
	pkgname=" -d $mod"
	pac_install
	#再只读挂载
	remount_aufs_r ${EXTRA_MODULES_INS_DIR}/${mod}
   	# 导出已经安装的软件清单(独立模块，含版本信息)
	$PACMAN -Q -r ${EXTRA_MODULES_INS_DIR}/${mod} >> ${EX_MODULE_LIST}
   done
   msg2 "附加模块 $EXTRAMODULES 安装完成."
   # 卸载UNION
   msg2 "卸载aufs件系统 ${UNION}."
   umount -l ${UNION}

   # 模块清理，删除不需要的文件
   pac_clean
}

function get_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中需要检测依赖关系的软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {dep_pkg=""}{if ($1 !~ /^#+/) {if (NF == 1) {dep_pkg=dep_pkg " " $1}}}END {print dep_pkg}' $1)
}
function get_d_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中无需检测依赖关系的软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {nodep_pkg=""}{if ($1 !~ /^#+/) { if (NF == 2) {nodep_pkg=nodep_pkg " " $2}}}END {print nodep_pkg}' $1)
}
function get_all_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中所有软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {all_pkg=""}{if ($1 !~ /^#+/) { {all_pkg=nodep_pkg " " $1" "$2}}}END {print all_pkg}' $1)
}

cmd_install ()
{

   # 软件清单文件夹
   [ -d ${PACKLIST} ] && rm -R ${PACKLIST}
   mkdir -p ${PACKLIST}

   [ -d ${UNION}/dev ] && rm -rf ${UNION}/dev
   msg "开始进行Archlive的制作..."
   msg2 "开始将$LISTDIR里面的软件安装/更新到对应模块文件夹"
   # 更新软件仓库信息
   sync_database
   [ -f ${PACKLIST}/updated.list ] && rm -f ${PACKLIST}/updated.list
   for mod in ${MODULES}; do
	#如果模块名以#开头则忽略
	#[ "$(case $mod in \#*) echo 0 ;; esac)" ] && continue  #不再需要，已经整理过
        [ ! -d ${MODULEDIR}/${mod} ] && mkdir -p ${MODULEDIR}/${mod}
	remount_aufs_w ${MODULEDIR}/${mod}	
	
	plain "将模块软件清单整理后输出（去除被#注释的）"
 	cat "${PROFILE_DIR}/$LISTDIR/${mod}.list" | sed -r "s/#.*//g" | sed -r "/^$/d" >${PACKLIST}/${mod}.new
	plain "完成."

	# 如果已经存在对应模块，则将对应软件包及版本信息输出到清单并根据已经安装的软件升级
	pacman_local_data=${MODULEDIR}/${mod}/var/lib/pacman/local
	if [ -d ${pacman_local_data} ] && [ "x$(find ${pacman_local_data} -type f -name "desc")" != "x" ]; then
		$PACMAN -Q -r ${MODULEDIR}/${mod} > ${PACKLIST}/${mod}.old
		plain "已安装的程序及版本信息已导出到文件${PACKLIST}/${mod}.old"
		$PACMAN -Su -f --needed --noconfirm --config "${PACMANCONF}" -fr "${UNION}" >/dev/null
		plain "已有程序升级完成."
		# 安装清单中需要的但没有被安装的软件包
		# 无-d选项的
		pkgname=$(awk 'NR==FNR{a[$1];b[$2]}NR>FNR{if (!($2 in a)) {if (!($1 in a)) {print $0}}}' ${PACKLIST}/${mod}.old ${PACKLIST}/${mod}.new | grep -v "\-d")
		if [ "x$pkgname" != "x" ]; then plain "$pkgname 是新添加的(需要检测依赖关系)，需要安装..."; pac_install; fi
		# 有 -d 选项的
		pkgname=$(awk 'NR==FNR{a[$1];b[$2]}NR>FNR{if (!($2 in a)) {if (!($1 in a)) {print $0}}}' ${PACKLIST}/${mod}.old ${PACKLIST}/${mod}.new | grep "\-d")
		if [ "x$pkgname" != "x" ]; then plain "$pkgname 是新添加的(无需检测依赖关系)，需要安装..."; pac_install; fi
		# 删除已经安装的多余的软件
		#pkgname=$(awk 'BEGIN {OFS="\t"}NR==FNR{a[$0];b[$2]}NR>FNR{if (!($1 in b)) {if (!($1 in a)) {print $1}}}' ${PACKLIST}/${mod}.new ${PACKLIST}/${mod}.old)
		#if [ "x$pkgname" != "x" ]; then plain "$pkgname 在新清单中没有，需要删除..."; pac_remove; fi
	fi
	if [ "x$(find ${MODULEDIR}/${mod} -type f -name "desc")" = "x" ]; then
		touch ${PACKLIST}/${mod}.old
		if [ "${QUICK_INSTALL}" = "y" ]; then
			get_d_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.list
			if [ "x${pkgname}" != "x" ]; then
				pkgname="-d ${pkgname}"
				pac_install
			fi
			get_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.list
			[ "x${pkgname}" != "x" ] && pac_install
		else
	        	cat  "${PACKLIST}/${mod}.new" | while read pkgname; do
				[ "x$pkgname" = "x" ] && continue
				pac_install
	        	done
		fi
        	if [ -e "${PROFILE_DIR}/$LISTDIR/${mod}.removelist" ]; then
			if [ "${QUICK_INSTALL}" = "y" ]; then
				get_all_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.removelist
				if [ "x${pkgname}" != "x" ]; then
					pkgname="-d ${pkgname}"
					pac_remove
				fi
			else
	            		cat "${PROFILE_DIR}/$LISTDIR/${mod}.removelist" | grep -v "^#" | while read pkgname; do pac_remove; done
			fi
        	fi
	fi
	# 检测包含内核的模块中，文件系统模块是否齐全
	if [ -d ${MODULEDIR}/${mod}/lib/modules ] && [ "x$(find ${MODULEDIR}/${mod}/lib/modules -type f -name "*.ko")" != "x" ]; then
		msg2 "检查目标系统是否有足够的文件系统模块: aufs,squashfs等..."
		[ $(ls ${MODULEDIR}/${mod}/lib/modules | wc -l) -ge 2 ] && (error "目标系统中内核模块有两个或者两个以上的版本" && exit 1)
		fs_system="aufs squashfs"
		case ${ZIP_MODE} in 1|2) fs_system="${fs_system} sqlzma unlzma";; esac
		for fs_type in ${fs_system}; do
			if [ "x$(find ${MODULEDIR}/${mod}/lib/modules -type f -name "${fs_type}.ko")" = "x" ]; then
				if [ "${KERNEL_KEY_FS_INCLUDED}" != "y" ]; then
					error "目标系统不包含必须的${fs_type}文件系统模块, 请修改${PROFILE_DIR}/$LISTDIR/${mod}.list" && exit 1
				else
					warn "目标系统不包含必须的${fs_type}文件系统被编入了内核，在制作启动镜像的时候忽略${fs_type}找不到的错误."
				fi
			fi
		done
		green "完成!"
	fi

	# 不用软件包定制也可以本地化支持 (在安装glibc的模块中进行）
	if [ "x$(ls ${MODULEDIR}/${mod}/var/lib/pacman/local | grep "glibc-")" != "x" ]; then
	#if [ $(echo $mod | grep "base") ] && [ "x${SP_CUSTOM_DIR}" != "x" ]; then
		[ -d ${SP_CUSTOM_DIR} ] && cp -rf ${SP_CUSTOM_DIR}/* $UNION/
		[ -f ${SP_CUSTOM_DIR}/etc/locale.gen ] && chroot $UNION locale-gen
		[ -f ${SP_CUSTOM_DIR}/etc/rc.sysinit ] && chmod ago+x ${MODULEDIR}/${mod}/etc/rc.*
	fi
        if [ -e "${UNION}/etc/ld.so.conf" ]; then
            ldconfig -r ${UNION}
        fi
	# 输出最新模块软件清单
	$PACMAN -Q -r ${MODULEDIR}/${mod} > ${PACKLIST}/mod_${mod}.new
	if [ -f ${PACKLIST}/${mod}.old ]; then
		diff -ruNa ${PACKLIST}/${mod}.old ${PACKLIST}/mod_${mod}.new | grep "^[-,+][a-zA-Z]" > ${PACKLIST}/${mod}.list
		if [ "x$(cat ${PACKLIST}/${mod}.list)" != "x" ]; then
			green "${mod} 模块更新内容(-表示删除的包，+表示新加入的包)" >>${PACKLIST}/updated.list	
			cat ${PACKLIST}/${mod}.list >>${PACKLIST}/updated.list
		fi
	fi
	if [ -f ${MODULEDIR}/${mod}/etc/rc.conf ]; then
		# 备份Arch原始启动关机脚本，以便Larchin安装
		plain "备份Arch原始启动关机脚本，以便Larchin安装"
		for larchsavefile in ${MODULEDIR}/${mod}/etc/{rc.sysinit,rc.shutdown,rc.local}; do
			cp -f ${larchsavefile} ${larchsavefile}.larchsave
		done
		cp -f ./linux-live/liblinuxlive ${MODULEDIR}/${mod}/usr/lib/
		green "完成!"
   	fi
	# 重新只读挂载以进行下一个模块
	remount_aufs_r ${MODULEDIR}/${mod}
   done

   #如果附加程序模块已经包含在程序清单中则不另外安装制作，除非archlive.conf中特别设置
   [ "${RE_EXTRAMODULES}" != "y" ] && cmd_extramodules_install

   # 导出已经安装的软件清单
   $PACMAN -Q -r ${UNION} > ${PKGFILE}

   # 卸载UNION
   [ "x$(grep $UNION /proc/mounts)" != "x" ] && msg2 "卸载aufs件系统 ${UNION}." && umount -l ${UNION}

   # 清理不需要的文件
   [ "${RE_EXTRAMODULES}" = "y" ] && pac_clean
}

function mksquashfs_module () {
   plain "将${1}用$MKSQUASHFS进行压缩..."
   [ -d ${1}/usr/share/fonts ] && chmod 755 ${1}/usr/share/fonts
   [ -d ${1}/etc/fonts ] && chmod 755 ${1}/etc/fonts
   OPTION="-noappend ${OPTION}"
   if [ "${QUIET}" = "y" ]; then
	   $MKSQUASHFS ${1} ${2} ${OPTION} >/dev/null
   else
	$MKSQUASHFS ${1} ${2} ${OPTION}
   fi
   chmod 0755 ${2}
   green "${2}创建完成."
}
cmd_extramodules_squash () {

   plain "压缩独立程序模块..."
   if [ "${RE_EXTRAMODULES}" = "y" ]; then
	start=$(date +%s)
   fi
   [ ! -d ${EXTRA_MODULES_TARGET} ] && mkdir -p ${EXTRA_MODULES_TARGET}
   for module_dir in $(ls ${EXTRA_MODULES_INS_DIR}); do
	source_dir="${EXTRA_MODULES_INS_DIR}/${module_dir}"
	target_file="${EXTRA_MODULES_TARGET}/$(ls ${EXTRA_MODULES_INS_DIR}/${module_dir}/var/lib/pacman/local)-$ARCH.${EXT}"
	mksquashfs_module "${source_dir}" "${target_file}"
   done
   [ "${RE_EXTRAMODULES}" = "y" ] && green "独立模块在 $(echo $start $(date +%s) | awk '{ printf "%0.2f",($2-$1)/60 }') 分钟内完成压缩."
}

check_kernel()
{
   #preset_file=$(find $MODULEDIR -type f -name "kern*.preset")
   #kver_file=$(find $MODULEDIR -type f -name "kern*.kver")
   # 改成直接列出来节约时间
   preset_file=$(ls $MODULEDIR/${KERNEL_MOD}/etc/mkinitcpio.d/kern*.preset)
   kver_file=$(ls $MODULEDIR/${KERNEL_MOD}/etc/mkinitcpio.d/ker*.kver)
   right_kver_file="n"
   basedir=""
   case "${preset_file%/*/*/*}" in "${kver_file%/*/*/*}") basedir=${kver_file%/*/*/*} ;; esac
   [ "x$basedir" = "x" ] && error "目标系统无安装内核或者内核安装出错..." && usage 1
   case ${kver_file} in "$basedir$(grep source $preset_file | cut -d " " -f2)") right_kver_file="y";; esac
   if [ "${right_kver_file}" = "y" ]; then
	source ${kver_file} && kernelver=${ALL_kver}
	[ "x$kernelver" = "x" ] && (error "目标系统内核安装有误，或者内核程序包有问题..." && exit 1)
   fi

   # 不采用pacman解决问题
   kernel_desc_file="$(dirname $(grep "$(echo ${kver_file} | awk -F "etc" '{print $2}')" `find $basedir/var/lib/pacman/local` | cut -d ":" -f1))/desc"
   ker_pkgname=$(sed -n '2p' ${kernel_desc_file})
   ker_pkg_ver=$(sed -n '5p' ${kernel_desc_file})

   plain "目标系统内核程序名为 ${ker_pkgname}, 版本为${ker_pkg_ver}"
   plain "目标系统内核模块安装于 $basedir, 版本为$kernelver"
}

cmd_squash () {

   [ ! -d ${MODULEDIR} ] && (error "${WORK_DIR}下还没有安装模块，请先执行 install命令." && usage 1)
   msg "创建squash模块..."
   start=$(date +%s)

   msg2 "更新内核模块依赖关系..."
   check_kernel
   depmod -a -b ${basedir} ${kernelver}
   plain "完成."

   #squashfs压缩的基本模块存放位置 比如0_000_core-i686.sqfs
   moduleplace="${IMGROOT}/${CDNAME}/base"
   for module_dir in $MODULES; do
	#[ "$(case ${module_dir} in \#*) echo 0 ;; esac)" ] && continue
	case ${module_dir} in [1-9]_*) moduleplace="${IMGROOT}/${CDNAME}/modules";; esac
	source_dir="${MODULEDIR}/${module_dir}"
        target_file="${moduleplace}/$(basename ${module_dir})-$ARCH.${EXT}"

	# 如果不存在制作好的模块或者有更新则创建模块  ${PACKLIST}/${module_dir}.list存放对应模块的更新详情
        if [ ! "$(find $IMGROOT/$CDNAME -name $(basename  ${target_file}))" -o "x$(cat ${PACKLIST}/${module_dir}.list)" != "x" ]; then
		mksquashfs_module "${source_dir}" "${target_file}"
	fi
   done

   if [ "${USE_OVERLAY}" = "y" ] && [ -d ${WORK_DIR}/overlay ]; then 
	msg2 "创建附加设置模块overlay.${EXT}..."
	OVERLAY="${WORK_DIR}/overlay"
	mksquashfs_module  "${OVERLAY}" "${IMGROOT}/${CDNAME}/base/overlay.${EXT}"
   fi

   #如果附加程序模块已经包含在程序清单中则不另外安装制作
   [ "${RE_EXTRAMODULES}" != "y" ] && cmd_extramodules_squash

   minutes=$(echo $start $(date +%s) | awk '{ printf "%0.2f",($2-$1)/60 }')
   green "模块在 $minutes 分钟内完成创建."
}

cmd_boot_kernel_image () {

   # 日志文件
   LOG=${BUILDLOG}/create_boot_image.log
   [ -f ${LOG} ] && rm -f ${LOG}

   msg "准备archlive内核及内核镜像" | tee -a ${LOG}

   # 判断archlive内核镜像配置文件是否存在
   [ ! -e "${CPIOCONFIG}" ] && error "错误: live系统启动内核镜像配置文件 '${CPIOCONFIG}' 不存在, 退出." && usage 1

   check_kernel

   msg2 "拷贝内核文件${KER_FILE}..." | tee -a ${LOG}
   # KER_FILE 在配置文件archlive.conf中定义，默认为vmlinuz26
   [ ! -d "${IMGROOT}/${CDNAME}/boot" ] && mkdir -p "${IMGROOT}/${CDNAME}/boot"
   [ -f "${IMGROOT}/${CDNAME}/boot/${KER_FILE}" ]
   right_ker_file="n" 

   case $(grep "boot/${KER_FILE}" "$(dirname ${kernel_desc_file})/files") in boot/$KER_FILE) right_ker_file="y";; esac
   [ "${right_ker_file}" = "n" ] && error "目标系统的内核文件名不是${KER_FILE}，请再次检查配置文件和目标系统的内核程序包..." | tee -a ${LOG} && exit 1
   [ -f ${basedir}/boot/${KER_FILE} ] && cp -f "${basedir}/boot/${KER_FILE}" "${IMGROOT}/${CDNAME}/boot/${KER_FILE}"
   [ -f "${IMGROOT}/${CDNAME}/boot/${KER_FILE}" ] && plain "拷贝内核文件完成." | tee -a ${LOG}

   msg2 "创建${CDNAME}  live系统启动的内核镜像..." | tee -a ${LOG}
	plain "配置文件 ${CPIOCONFIG}, " | tee -a ${LOG}
	plain "基于目录 ${basedir}, " | tee -a ${LOG}
	plain "内核版本 ${kernelver} " | tee -a ${LOG}
	
   echo ""
   green "创建启动内核镜像可能要好几分钟时间，请稍候..."
   if [ "${QUIET}" = "y" ]; then append_cmd=">>${LOG}"; else append_cmd="| tee -a ${LOG}"; fi
   sh $MKINITCPIO -c "${CPIOCONFIG}" -b "${basedir}" -k "${kernelver}" -g \
		"${IMGROOT}/${CDNAME}/boot/archlive.img" ${append_cmd}
   if [ $? -ne 0 ]; then
	error "错误: 内核镜像创建失败..." | tee -a ${LOG}
	usage 1
   else
	green "内核启动镜像制作成功！" | tee -a ${LOG}
   fi
}

r_copy()
{
   CWD=$(pwd)
   cd $1
   SOURCE="$2"
   DEST="$3"
   echo "source: $1/$SOURCE target: $DEST" >>$4
   if [ -L "$SOURCE" ]; then
      REALPATH=$(readlink -f "$SOURCE")
      cp -r --parent -a "$REALPATH" "$DEST"
      ln -sf "$REALPATH" "$DEST/$SOURCE"
   else
      cp -r --parent -a "$SOURCE" "$DEST"
   fi
   [ "$?" -ne 0 ] && (echo "拷贝文件失败..." && exit 1)
   cd $CWD
}
# 判断指定$1下是否存在$2
# 如果不存在且宿主系统内核版本跟目标系统一致，则ROOT切换到宿主系统根目录
cp_all()
{
   ROOT=$1
   if [ ! -e $ROOT/$2 ]; then
	if [ "${same_ver}" = "y" ]; then
		ROOT="/"
		if [ ! -e $ROOT/$2 ]; then
			error "目标系统和宿主系统都不存在$2 " && exit 1
		fi
	else
		error "目标系统不存在$2，宿主系统的该文件不可用——版本不一致." && exit 1
	fi
   fi
   local source=$2
   local target=$3
   local log=$4
   r_copy $ROOT $source $target $log
}
create_base_module (){

   [ ! -d ${WORK_DIR} ] && (warn "工作目录还不存在，请先 install..." && exit 1)
   msg "创建基本模块archlive.sqfs ..."
   [ -f ${IMGROOT}/${CDNAME}/archlive.sqfs ] && rm -f ${IMGROOT}/${CDNAME}/archlive.sqfs

   live_dir=./linux-live
   . ${live_dir}/liblinuxlive || exit 1
   LIVECDNAME=${CDNAME}
   ADDLOCALE=$(echo ${REMAIN_LOCALE} | tr "|" " ")

   # 日志 (比较关键，独立日志)
   [ ! -d ${IMGROOT}/${CDNAME} ] && mkdir -p ${IMGROOT}/${CDNAME}
   [ ! -d ${BUILDLOG} ] && mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/create_base_module.log
   [ -f ${LOG} ] && rm -f ${LOG}

   # 基本目录、临时工作目录
   msg2 "创建基本模块临时目录..." | tee -a ${LOG}
   base_module_tree="${MODULEDIR}/archlive"
   [ -d ${base_module_tree} ] && rm -rf ${base_module_tree}
   mkdir -pv ${base_module_tree} >> ${LOG}
   mkdir -pv ${base_module_tree}/{etc,dev,bin,mnt,proc,lib,sys,tmp,var/log} >> ${LOG}

   msg2 "创建基本设备文件..."  | tee -a ${LOG}
   mknod ${base_module_tree}/dev/console c 5 1
   mknod ${base_module_tree}/dev/fb0 c 29 0
   mknod ${base_module_tree}/dev/null c 1 3
   mknod ${base_module_tree}/dev/zero c 1 5
   mknod ${base_module_tree}/dev/ram b 1 1
   mknod ${base_module_tree}/dev/systty c 4 0
   mknod ${base_module_tree}/dev/tty c 5 0
   mknod ${base_module_tree}/dev/fuse c 10 229
   for i in 1 2 3 4 5 6; do
	mknod ${base_module_tree}/dev/tty$i c 4 $i;
   done

   msg2 "拷贝文件(启动文件、程序文件等)到基本模块..." | tee -a ${LOG}
   touch ${base_module_tree}/etc/{m,fs}tab
   cat ${live_dir}/liblinuxlive | sed -r 's/^LIVECDNAME=.*/LIVECDNAME="'$LIVECDNAME'"/' > ${base_module_tree}/liblinuxlive
   cp -av ${live_dir}/fuse/* ${base_module_tree} >> ${LOG}
   cp -av ${live_dir}/httpfs/* ${base_module_tree} >> ${LOG}
   cp -av ${live_dir}/posixovl/* ${base_module_tree} >> ${LOG}
   cp -av ${live_dir}/ntfs-3g/* ${base_module_tree} >> ${LOG}
   chmod ago+x ${live_dir}/rootfs/bin/*
   cp -afv ${live_dir}/rootfs/* ${base_module_tree} >> ${LOG}

   # 基本模块中使用busybox来替代常用程序，比如vi wget等
   for i in $(${live_dir}/rootfs/bin/busybox --help | grep -v Copyright | grep , | tr , " "); do
	[ ! -f ${base_module_tree}/bin/$i ] && ln -sv busybox ${base_module_tree}/bin/$i >> ${LOG}
   done

   ln -sfv bin ${base_module_tree}/sbin >> ${LOG}
   cp -v ${live_dir}/{linuxrc,cleanup} ${base_module_tree} >> ${LOG}
   chmod ago+x ${base_module_tree}/{linuxrc,cleanup,bin/init}

   msg2 "检查目标系统安装内核的模块及内核版本..." | tee -a ${LOG}
   check_kernel
   [ "x$basedir" = "x" ] && (error "没有找到安装内核的模块..." | tee -a ${LOG} && exit 1)
   if [ "x$(echo $basedir | grep "${WORK_DIR}")" = "x" ]; then
	error "工作目录下还没有安装有内核程序包的模块，或者安装不完整..." | tee -a ${LOG}
	exit 1
   fi
   plain "目标系统内核安装于$basedir，内核版本为${kernelver}" >> ${LOG}

   msg2 "拷贝内核模块：文件系统、设备驱动等..." | tee -a ${LOG}
   kernel_modules_dir="lib/modules/${kernelver}"
   host_kernel_ver=$(uname -r)
   same_ver=""
   case ${kernelver%-*} in ${host_kernel_ver}) same_ver="y";; esac

   FS="aufs squashfs fuse isofs udf fat ntfs ext3 ext4 btrfs reiserfs xfs nls"
   BASE_DRIVERS="cdrom ide"
   USB="storage host/ehci-hcd.ko host/ohci-hcd.ko host/uhci-hcd.ko"
   PCMCIA="pcmcia_core.ko pcmcia.ko rsrc_nonstatic.ko yenta_socket.ko"
   for mod in ${FS} ${BASE_DRIVERS} ${USB} {PCMCIA}; do
	cat ${basedir}/${kernel_modules_dir}/modules.order | fgrep /$mod.ko | while read mod_line; do
		cp_all ${basedir} ${kernel_modules_dir}/${mod_line} ${base_module_tree} ${LOG}
	done
   done

   # 网卡模块
   NET="3c59x acenic atl1 de4x5 dgrs eepro100 e1000 epic100 hp100 ne2k-pci olympic pcnet32 r8169 rcpci 8139too 8139cp sktr skge sky2\
	tulip via-rhine yellowfin tg3 dl2k ns83820 depca ibmtr 3c501 3c503 3c505 3c507 3c509 3c515 ac3200 acenic at1700 cosa cs89x0\
	de4x5 de600 de620 e2100 eepro eexpress es3210 eth16i ewrk3 fmv18x forcedeth hostess_sv11 hp-plus hp lne390 ne3210 ni5010\
	ni52 ni65 sb1000 sealevel smc-ultra sis900 smc-ultra32 smc9194 wd"
   for mod in ${NET}; do
	cat ${basedir}/${kernel_modules_dir}/modules.dep | fgrep /$mod.ko | while read mod_dep_line; do
		for dep in $(echo ${mod_dep_line} | tr -d ":"); do
			cp_all ${basedir} ${kernel_modules_dir}/$dep ${base_module_tree} ${LOG}
		done
	done
   done

   msg2 "加入${CONFIG_FILE}中设置的语言支持..."
   if [ "$ADDLOCALE" != "" ]; then
	localeroot=$(find ${MODULEDIR} -type f -name "locale.alias" | grep "usr/share/locale/locale.alias" | grep -v "${base_module_tree}" | grep -v "${EXTRA_MODULES_INS_DIR}")
	localeroot=${localeroot%/usr/share/locale/locale.alias}
	echo "localeroot=${localeroot}" >>${LOG}
	plain "拷贝locale文件, 支持的locale: $ADDLOCALE" | tee -a ${LOG}
	copylocales ${localeroot} ${base_module_tree} $ADDLOCALE
   fi

   msg2 "更新基本模块内核模块依赖关系" | tee -a ${LOG}
   depmod -a -b ${base_module_tree} ${kernelver}

   msg2 "用squash压缩基本模块中的usr drivers目录..." | tee -a ${LOG}
   mksquashfs_module ${base_module_tree}/usr ${base_module_tree}/usr.lzm >>${LOG}
   chmod ago-x ${base_module_tree}/usr.lzm
   rm -Rf ${base_module_tree}/usr/*
   mksquashfs_module ${base_module_tree}/lib/modules/${kernelver}/kernel/drivers ${base_module_tree}/drivers.lzm >>${LOG}
   chmod ago-x ${base_module_tree}/drivers.lzm
   rm -Rf ${base_module_tree}/lib/modules/${kernelver}/kernel/drivers/*

   msg2 "用squash压缩基本模块..." | tee -a ${LOG}
   mksquashfs_module ${base_module_tree} ${IMGROOT}/${CDNAME}/archlive.sqfs >>${LOG}
   chmod ago-x ${IMGROOT}/${CDNAME}/archlive.sqfs
   chmod 0444 "${IMGROOT}/${CDNAME}/archlive.sqfs"
   msg2 "基本模块archlive.sqfs制作完成!" | tee -a ${LOG}
}

cmd_img () {

   msg "准备制作镜像所需要的程序模块..."

   #判断${IMGROOT}下的模块是否是需要的——由${CONFIG_FILE}: archlive.conf定义
   
   msg2 "清理不需要的模块到${NO_NEED_MODULES_DIR}下"
   [ ! -d ${NO_NEED_MODULES_DIR} ] && mkdir -p ${NO_NEED_MODULES_DIR}
   for module_file in $(find ${IMGROOT} -name "*.sqfs" -o -name "*.lzm"); do
	needed="n"
	case ${module_file} in */overlay.${EXT}) case ${USE_OVERLAY} in y) needed="y" && break;; esac;; esac
	case ${module_file} in */archlive.sqfs) needed="y" && break;; esac
	module_name=$(basename ${module_file} -${ARCH}.${EXT})
	case $MODULES in *${module_name}*) needed="y" && break;; esac
	case $EXTRAMODULES in *${module_name}*) needed="y" && break;; esac
	if [ "$needed" = "n" ]; then
		warn "$module_file未在${CONFIG_FILE}中定义，移除到${NO_NEED_MODULES_DIR}下"
		mv -f $module_file ${NO_NEED_MODULES_DIR}/
	fi
   done
   green "镜像目录模块清理完毕."

   # 拷贝附加程序模块
   if [ -d $EXTRAPACKAGEDIR ]; then
	[ ! -d ${EXTRA_PACKAGE_TARGET} ] && mkdir -p ${EXTRA_PACKAGE_TARGET}
   	for mod in $EXTRAPACKAGEDIR/*.$EXT; do msg2 "拷贝附加程序模块 $mod ..." && cp $mod ${EXTRA_PACKAGE_TARGET}/; done
	green "完成."
   fi

   msg2 "将软件清单放到镜像目录中"
   cat ${PKGFILE} | sort > ${IMGROOT}/${CDNAME}/${CDNAME}.list
   green "完成."

   msg2 "准备启动文件..."
   bootflags=""
   if [ "$BOOT" = "grub" -o "$BOOT" = "grub-gfx" ]; then
	[ ! -d "${IMGROOT}/boot/grub" ] && mkdir -p "${IMGROOT}/boot/grub"
	bootfile=$(find $MODULEDIR -type f -name "stage2_eltorito")
	if [ ! "x${bootfile}" = "x" ]; then
		cp -f ${bootfile} ${IMGROOT}/boot/grub/
		plain "找到引导程序${bootfile}，使用该引导程序覆盖cd-root里可能已经存在的引导程序."
	else
		if [ -f ${IMGROOT}/boot/grub/stage2_eltorito ]; then
			error "目标系统中没有安装$BOOT，使用cd-root中原来的引导程序..."
		else
			warn "目标系统中没有选择安装$BOOT, 在宿主系统中查找..."
			grub --help 2>&1 >/dev/null
			[ $? -ne 0 ] && error "宿主系统也不存在$BOOT. 无法继续!请选择其他引导程序或者安装$BOOT..." && usage 1
			bootfile=$(find $MODULEDIR -type f -name "stage2_eltorito")
			if [ ! "x${bootfile}" = "x" ]; then
				cp -f ${bootfile} ${IMGROOT}/boot/grub/
				green "在${bootfile_dir}目录下找到引导程序."
			else 
				error "宿主系统也没有安装$BOOT. 无法继续!请选择其他引导程序或者安装$BOOT..." && usage1
			fi
		fi
	fi
	bootflags="-b boot/grub/stage2_eltorito"
	green "引导程序$BOOT 准备完毕."
   fi

   if [ "$BOOT" = "syslinux" -o "$BOOT" = "isolinux" ]; then
	[ ! -d ${IMGROOT}/boot/isolinux ] && mkdir -p ${IMGROOT}/boot/isolinux
	boot_mod=$(basename "$(grep "syslinux" `find ${PACKLIST} -name "*.new"` |head -1)" .new:syslinux)
	bootfile_dir=${MODULEDIR}/${boot_mod}/usr/lib/syslinux
	if [ -f ${bootfile_dir}/isolinux.bin ]; then
		cp -f ${bootfile_dir}/*.* ${IMGROOT}/boot/isolinux/
	elif [ ! -f ${IMGROOT}/boot/isolinux/isolinux.bin ] && [ -f ${IMGROOT}/boot/syslinux/isolinux.bin ]; then
		bootfile_dir=${IMGROOT}/boot/syslinux
		cp -f ${bootfile_dir}/*.* ${IMGROOT}/boot/isolinux/
	else
		warn "目标系统和${IMGROOT}下都没有syslinux启动文件，现在从宿主系统查找..."
		bootfile=$(find /usr -type f -name "isolinux.bin")
		bootfile_dir=${bootfile%/isolinux.bin}
		if [ -f ${bootfile_dir}/isolinux.bin ]; then
			cp -f ${bootfile_dir}/*.* ${IMGROOT}/boot/isolinux/
		else
			error "宿主系统也不存在syslinux. 无法继续，请选择其他启动程序或者安装$BOOT..." && usage 1
		fi
	fi
	green "在${bootfile_dir}下找到syslinux的启动程序."
	bootflags="-b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat"
	green "引导程序$BOOT 准备完毕."
   fi

   if [ "$BOOT" = "grub2" ]; then
	[ ! -d ${IMGROOT}/boot/grub ] && mkdir -p ${IMGROOT}/boot/grub
	grub2_mkimg=$(find $MODULEDIR -type f -name "grub-mkimage")
	if [ "x${grub2_mkimg}" = "x" ]; then
		[ ! -x /bin/grub-mkimage ] && error "目标系统及宿主系统中都没有安装grub2，\n 宿主系统安装grub2后再 sudo sh ./$APPNAME img 工作目录 来重新制作镜像。" && usage 1
		grub2_mkimg="/bin/grub-mkimage"
		cp -f /usr/lib/grub/i386-pc/* ${IMGROOT}/boot/grub/
		cp -f /usr/share/grub/* ${IMGROOT}/boot/grub/
	else
		cp -f $(find $MODULEDIR -type d -name "i386-pc")/* ${IMGROOT}/boot/grub/
		cp -f $(find $MODULEDIR -type f -name "*.pf2") ${IMGROOT}/boot/grub/
	fi
	${grub2_mkimg} -d ${IMGROOT}/boot/grub/ -o core.img biosdisk pc gpt iso9660 fat ntfs ext2 pxe\
		reiserfs gfxterm ntfs
	cat ${IMGROOT}/boot/grub/{cdboot.img,core.img} > ${IMGROOT}/boot/grub/grub2cd.bin
	bootflags="-b boot/grub/grub2cd.bin"
	green "引导程序$BOOT 准备完毕."
   fi
   if [ "$IMG_TYPE" = "img" ]; then
        msg2 "基于目录${IMGROOT}创建USB DISK镜像img..."
        ${START_DIR}/mkusbimg "${IMGROOT}" "${IMGNAME}"
   fi
   if [ "$IMG_TYPE" = "iso" ]; then
        msg2 "基于目录${IMGROOT} 使用mkisofs v${mkisofs_version}来创建ISO镜像..."
        qflag=""
        [ "${QUIET}" = "y" ] && qflag="-q"
        mkisofs ${qflag} -v -J -R -D -r -l $bootflags -uid 0 -gid 0 \
	    -input-charset utf-8 -p "${AUTHOR}" \
            -no-emul-boot -boot-load-size 4 -boot-info-table \
            -publisher "${PUBLISHER}" \
            -A "${CDNAME}" -V "${CDNAME}" \
            -o "${IMGNAME}" "${IMGROOT}" >/dev/null
       isohybrid "${IMGNAME}"
       md5sum "${IMGNAME}" > "${IMGNAME}".md5
       green "${IMGNAME}制作成功！"
   fi
}
###--------------------------------------主程序调用------------------------------------------------------
case ${CMD_NAME} in
	prepare) cmd_prepare ;;
	install) cmd_prepare; cmd_install ;;
	modules) prepare_pacman; cmd_extramodules_install; cmd_extramodules_squash ;;
	squash) cmd_squash ;;
	bootimage) cmd_boot_kernel_image ;;
	core_module) create_base_module ;;
	img) cmd_img ;;
	all) cmd_prepare; cmd_install; cmd_squash; cmd_boot_kernel_image; prepare_base_module; cmd_img ;;
	*) error "错误的命令" && usage 1 ;;
esac
msg "程序执行 ${APPNAME} $cmdline 结束!"
