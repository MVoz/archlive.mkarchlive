RST="\033[1;0m"
# regular colors
K="\033[0;30m"    # black
R="\033[0;31m"    # red
G="\033[0;32m"    # green
Y="\033[0;33m"    # yellow
B="\033[0;34m"    # blue
M="\033[0;35m"    # magenta
C="\033[0;36m"    # cyan
W="\033[0;37m"    # white
# emphasized (bolded) colors
EMK="\033[1;30m"
EMR="\033[1;31m"
EMG="\033[1;32m"
EMY="\033[1;33m"
EMB="\033[1;34m"
EMM="\033[1;35m"
EMC="\033[1;36m"
EMW="\033[1;37m"
# background colors
BGK="\033[40m"
BGR="\033[41m"
BGG="\033[42m"
BGY="\033[43m"
BGB="\033[44m"
BGM="\033[45m"
BGC="\033[46m"
BGW="\033[47m"

HYB="\033[1;33;44m"
HGK="\033[1;32;40m"
HBK="\033[1;34;40m"
HWK="\033[1;37;40m"
HRK="\033[1;31;40m"

plain() { 
	if [ $# -eq 2 ] && [ "$1" = "-n" ]; then
		if [ "${COLOR}" = "y" ]; then 
			echo -n -e "$W$RST      $2$RST"
		else
			echo -n -e "      $2"
		fi
	else
		if [ "${COLOR}" = "y" ]; then 
			echo -e "$W$RST      $@$RST"
		else
			echo -e "      $@"
		fi
	fi
}
msg() {
	if [ "${COLOR}" = "y" ]; then 
		echo -e "$EMB==>$RST$HWK $@$RST"
	else
		echo -e "==> $@"
	fi
}
msg2() {
	if [ $# -eq 2 ] && [ "$1" = "-n" ]; then
		if [ "${COLOR}" = "y" ]; then 
			echo -n -e "$HBK   ->$RST$W $2$RST"
		else
			echo -n -e "  -> $2"
		fi
	else
		if [ "${COLOR}" = "y" ]; then 
			echo -e "$HBK   ->$RST$W $@$RST"
		else
			echo -e "  -> $@"
		fi
	fi
}
warn() {
	if [ "${COLOR}" = "y" ]; then 
		echo -e "\n$Y==> $(gettext "WARNING:") $@$RST"
	else
		echo -e "\n ==> $(gettext "WARNING:") $@"
	fi
}
error() {
	if [ "${COLOR}" = "y" ]; then 
		echo -e  "\n$HRK==> $(gettext "ERROR:") $@$RST"
	else
		echo -e "\n==> $(gettext "ERROR:") $@"
	fi
}
hgreen() {
	if [ "${COLOR}" = "y" ]; then
		echo -e "$HGK      $@$RST"
	else
		echo "      $@"
	fi
}
green() {
	if [ "${COLOR}" = "y" ]; then
		echo -e "$G      $@$RST"
	else
		echo -e "      $@"
	fi
}
yellow() {
	if [ "${COLOR}" = "y" ]; then
		echo -e "$HYB$@$RST"
	else
		echo -e "$@"
	fi
}

# mkarchlive 用法
usage ()
{
   echo  ""
   hgreen " ${APPNAME} 使用说明："
   echo  "       --------------------"
   echo "       本制作程序须用管理员身份或者sudo来执行，须要aufs文件系统的支持。"
   echo "       为确保本脚本正常运行，宿主系统（运行本脚本的系统，可以不是Arch GNU/Linux)"
   echo "       须确保有如下程序/命令："
   echo "       shell sed grep gawk module-init-tools(depmod) util-linux-ng(mount) "
   echo "       glibc(ldconfig) findutils(find) coreutils(ls, cut, tr, echo, rm, mkdir, "
   echo "       cp, cat, chown, chmod, head, mknod, tee, touch, sort, ln, md5sum)"
   echo "       如果制作livecd (iso格式), 还需要有cdrkit等软件(mkisofs)。"
   echo "       如果强制使用pacman.static，保宿主系统还须确保有如下程序："
   echo "       wget tar"
   echo "       以上程序中，括号里面的是本脚本调用的命令，确保宿主系统包含这些命令! "
   echo ""
   hgreen " 注意："
   green "          1、输入的选项及命令定义的参数优先性高于配置文件."
   echo ""
   hgreen " 用法：${APPNAME} [选项] 命令 <命令选项>"
   green " 一般选项:"
   echo "        -c CDNAME        目标镜像名. 默认: archlive"
   echo "        -P               指定配置文件, 两种方式："
   echo -e "                         1. 指定配置文件夹名，在profile目录下查找对应配置文件夹下的\
	\n                            archlive.conf或者CDNAME.conf作为配置文件;"
   echo -e "                         2. 指定配置文件的绝对路径，或相对mkarchlive的相对路径.\
	\n                            此时，配置文件所在文件夹下必须包含必要的其他配置文件."
   echo "        -A               指定Arch为i686或者x86_64或者dul(双模式)"
   echo "        -i CPIO_CONFIG   用CONFIG 作为archlive启动内核配置文件. "
   echo -e "        -b BOOT	         启动选项(syslinux,isolinux,grub,grub-gfx, grub2 \
	 \n	 	         默认配置文件夹cd-root中没有提供grub2的菜单文件)"
   echo "        -z               指定模块压缩格式，sqfs或者lzma"
   echo "        -C               指定安装过程中下载的软件包存放位置"
   echo "        -f               强制覆盖现有的工作目录等，全部重新制作"
   echo "        -v               显示运行输出结果."
   echo "        -h               本帮助信息."
   green " 命令:"
   echo "        prepare                   : 准备iso根目录结构及overlay (如果需要) "
   echo "        install <工作目录>        : 将程序安装到工作目录下"
   echo "        clean <工作目录>          : 根据配置文件清理、精简目标系统"
   echo "        remount <工作目录>        : 将之前制作的模块文件夹重新可写挂载"
   echo "        squash <工作目录>         : 从指定的目录创建squash模块"
   echo "        overlay <工作目录>        : 准备overlay目录到工作目录下，并用压缩为squash模块"
   echo "        bootimage <工作目录>      : 从指定的目录制作archlive启动内核镜像."
   echo "        img <工作目录> [目标镜像] : 从指定目录创建目标镜像"
   echo "        all <工作目录> [目标镜像] : 顺序执行以上所有命令"
   echo "        solemodules <工作目录>    : 仅在工作目录下制作独立程序模块"
   echo ""
   green "  一般用 all 来自动执行;  为了完全自由定制可以: "
   green "  先 prepare, 然后修改overlay、iso启动配置文件;"
   green "  再 install, clean, 然后修改模块中配置文件, 或者 remount后直接修改union下文件;"
   green "  再 squashfs, 再 bootimage  img "
   echo  "       --------------------"
   echo ""
   exit $1
}
start_notice ()
{
   echo ""
   green "************************************************************************"
   hgreen "				运行本程序前： "
   hgreen "***请详细阅读readme, archlive.conf等文件——了解详细的操作过程后继续***"
   echo -n "                "; yellow "*** 本脚本 5 秒后开始执行，Ctrl+C 终止程序 ***"
   green "************************************************************************"
   echo ""
}

check_host_aufs ()
{
   #if [ "${KERNEL_KEY_FS_INCLUDED}" = "n" ]; then
	#注释掉以上，强行检查
	case "$cmdline" in *all*|*install*|*solemodules*)
		# 挂载aufs文件系统并判断是否已经挂载成功
		modprobe aufs
		[ $? -ne 0 ] && (error "无法装载aufs文件系统模块,请确保宿主系统aufs内核模块被正确安装. " && exit 1)
		rmmod aufs
		;;
	esac
   #fi
}
check_host_cmd ()
{
   # 检测宿主系统是否包含本脚本调用的命令
   need_cmd="wget tar bsdtar sed grep gawk depmod mount ldconfig find ls cut tr echo rm mkdir \
	cp cat chown chmod head mknod tee sort touch ln md5sum mkisofs openssl stat"
   host_cmd_dir=$(echo $PATH | tr ":" "\n")
   [ -f /tmp/cmd_list ] && rm -f /tmp/cmd_list
   for dir in ${host_cmd_dir}; do
	if [ -d $dir ]; then 
		ls -1 $dir >>/tmp/cmd_list
	fi
   done
   for cmd in ${need_cmd}; do
	if [ "x$(grep "$cmd" /tmp/cmd_list)" = "x" ]; then
		error "宿主系统不存在(或者在系统PATH指定的路径下不存在)必须的命令$cmd"
		error "请安装后再运行本制作脚本..."
		usage 1
   	fi
   done
}

# 判断宿主系统是否是Arch
# 将判断结果赋值给变量 ARCH_HOST
# 并将宿主系统pacman版本赋值给host_pacman_version
host_isnot_arch ()
{
   ARCH_HOST="n"
   host_pacman_version=""
   if [ -d /var/lib/pacman/local ]; then
	if which pacman 2>/dev/null >/dev/null; then
		ARCH_HOST="y"
		host_pacman_version=$(pacman -V | grep "Pacman" | head -1 | tr -s " " | cut -d " " -f4)
	fi
   fi
}

# 根据配置文件archlive.conf存放位置与archlive.conf中PROFILE_DIR定义的值是否一致来判断查找到的配置文件是否是正确
config_is_right () {
   case "${CONFIG_FILE}" in "./${PROFILE_DIR}/archlive.conf") return 0;; esac
   return 1
}

check_config ()
{
	# config_file 由命令行参数指定
	if [ "x${config_file}" = "x" ]; then
		# 没有指定配置文件/配置名， 采用默认配置
		if [ -f "${START_DIR}/profiles/archlive/archlive.conf" ]; then
			CONFIG_FILE="${START_DIR}/profiles/archlive/archlive.conf"
		else
			error "没有指定制作配置文件、也不存在默认制作配置文件， \n请重新指定配置文件名或者重新获取archlive制作工具."
			exit 1
		fi
	elif [ -f "${config_file}" ]; then
		CONFIG_FILE="${config_file}"
		PROFILE_DIR="$(dirname ${CONFIG_FILE})"
	elif [ -d "${START_DIR}/profiles/${config_file}" ]; then
		CONFIG_FILE="${START_DIR}/profiles/${config_file}/archlive.conf"
		if [ ! -f ${CONFIG_FILE} ] && [ "x$cdname" != "x" ]; then
			CONFIG_FILE="${START_DIR}/profiles/${config_file}/${cdname}.conf"
			if [ ! -f ${CONFIG_FILE} ]; then
				error "指定的配置名目录下无配置文件, 请指定具体配置文件名, \n或者-c指定配置文件名，该名同时也是目标镜像名."
				exit 1
			fi
		fi
		PROFILE_DIR="$(dirname ${CONFIG_FILE})"
	else
		error "指定的配置名/配置文件名不存在，请重新指定."
		exit 1
	fi

	source ${CONFIG_FILE}
	if [ "x${boot_kernel_config1}" != "x" ]; then
		CPIOCONFIG="${PROFILE_DIR}/${boot_kernel_config1}"
	elif [ "x${boot_kernel_config}" != "x" ]; then
		CPIOCONFIG="${PROFILE_DIR}/${boot_kernel_config}"
	else
		# 命令行和配置文件都没有指定启动内核配置文件，采用默认设置
		CPIOCONFIG="${START_DIR}/profiles/archlive/archlive-mkinitcpio.conf"
	fi
	if [ ! -f "${CPIOCONFIG}" ]; then
		error "配置文件错误: 没有指定启动内核配置文件，同时默认配置文件不存在.\n请重新指定配置文件名或者重新获取archlive制作工具."
		exit 1
	fi

	if [ "x$boot" != "x" ]; then
		BOOT="$boot"
	elif [ "x$BOOT" = "x" ]; then
		warn "命令行和配置文件都没有指定目标镜像启动模式, 采用默认的isolinux."
		BOOT="isolinux"
	fi
	case $BOOT in
		isolinux) BOOT="isolinux" ;;
		syslinux) BOOT="syslinux" ;;
		grub2) BOOT="gub2" ;;
		grub*) BOOT="grub" ;;
		*) BOOT="isolinux"; warn "未知的或者暂时不支持的目标镜像引导程序，采用默认的isolinux" ;;
	esac

	if [ "x$cdname" != "x" ]; then
		CDNAME="$cdname"
	elif [ "x$CDNAME" = "x" ]; then
		warn "命令行和配置文件都没有指定live系统名，采用默认的\"archlive\""
		CDNAME="archlive"
	fi

	if [ "x${zip_mode}" != "x" ]; then
		case ${zip_mode} in sqfs|1) ZIP_MODE=1;;
				lzma|2) ZIP_MODE=2;;
				*) warn "命令行上参数指定了无效的压缩模式，采用默认的标准压缩.";
					ZIP_MODE=1;;
				esac
	elif [ "x${ZIP_MODE}" = "x" ]; then
		warn "命令行参数和配置文件都没有指定模块压缩方式，采用默认的标准压缩."
		ZIP_MODE=1
	fi

	if [ "x${arch1}" != "x" ]; then
		case "${arch1}" in
			i686|x86_64) ARCH=${arch1}; arch=${arch1};;
			dul) ARCH=""; arch=${arch1};;
			*) warn "命令行指定了无效的 ARCH ${arch1}, 采用默认的 i686. "; ARCH="i686" ;;
		esac
	elif [ "x${arch}" != "x" ]; then
		case "${arch}" in
			i686|x86_64) ARCH=${arch};;
			dul) ARCH="";;
			*) warn "命令行指定了无效的 ARCH ${arch}, 采用默认的 i686. "; ARCH="i686" ;;
		esac
	else
		warn "命令行和配置文件均没有指定 ARCH, 采用默认的 i686."
		ARCH="i686"
		arch="i686"
	fi

	if [ "x${cache_dir}" != "x" ]; then
		CACHE="${cache_dir}"
	fi

	# 根据配置文件设置更新消息提示风格，无设置默认有特别颜色显示提示消息
	if [ "${COLOR}" != "n" ]; then
		COLOR="n"
	else
		COLOR="y"
	fi

	# 
	if [ "${ARCH_HOST}" = "n" ] && [ "${USE_STATIC_PACMAN}" != "y" ]; then
		warn "宿主系统不是Arch，${CONFIG_FILE}中变量USE_STATIC_PACMAN \n设置有误，采用STATIC_PACMAN安装系统."
		USE_STATIC_PACMAN=y
	fi
}

# 自定义软件仓
# $1 ARCH (i686 or x86_64)
# $2 预建立软件仓的位置
# $3 预建立的软件仓的名称
function custom_repo () 
{
   log=${BUILDLOG}/$1-create_repo.log
   if [ -d $2 ]; then
	#if [ "${QUIET}" = "y" ]; then
		sh ${START_DIR}/lib/create_repo -A $1 $2 $3 >>$log 2>&1
   	#else
	#	sh ${START_DIR}/lib/create_repo -A $1 $2 $3 | tee $log
   	#fi
   else
	error "$2 不存在!" | tee -a $log
	usage 1
   fi
}

# $1 repo_name
# $2 repo_location
# $3 pacman.conf位置
function is_in_pacmanconf () 
{
   a=$(cat ${3} | sed -r "s/#.*//")
   case $a in 
	*[${1}]*) case $a in *file://${2}*) return 0;; esac
	;;
	esac
   return 1
}

# 将自定义的软件仓加入到PACMANCONF中，默认第一优先
# pacman.conf须是在# and they will be used before the default mirrors.行后开始定义软件仓.
# $1 repo_name
# $2 repo_location
# $3 pacman.conf位置
# $4 log
function add_customrepo2pacmanconf ()
{
   LOG="${4}"
   sed -i "/# Places for cutom repo/ a\
	\ \n[${1}]\
	\nServer = file://$2" ${3}
   green "将自定义软件仓加入${3}完成" | tee -a ${LOG}
}

prepare_overlay (){

   LOG="${1}"

   msg2 "准备Archlive 系统配置文件目录overlay" | tee -a ${LOG}
   [ -d ${WORK_DIR}/overlay ] && rm -rf ${WORK_DIR}/overlay
   if [ -d ${PROFILE_DIR}/overlay ]; then
	mkdir -p ${WORK_DIR}/overlay
	cp -rf ${PROFILE_DIR}/overlay/* ${WORK_DIR}/overlay/
   else
      if [ ! -f overlay.tgz ]; then
		plain -n "下载Archlive附加配置文件overlay.tgz" | tee -a ${LOG}
		wget -q "${TGZURL}/overlay.tgz"  2>&1 > /dev/null
		green "完成!" | tee -a ${LOG}
      fi
      plain -n "释放Archlive附加配置文件overlay.tgz" | tee -a ${LOG}
      tar -xzvpf overlay.tgz -C ${WORK_DIR}   2>&1 > /dev/null
      green "完成!" | tee -a ${LOG}
   fi
   OVERLAY=${WORK_DIR}/overlay
   for theme in ${THEME}; do 
   	if [ ! -f "${theme}-theme.tgz" ]; then
		plain -n "下载主题包文件${theme}-theme.tgz" | tee -a ${LOG}
            	wget -q "${TGZURL}/${theme}-theme.tgz"  2>&1 > /dev/null
		green "完成!" | tee -a ${LOG}
       fi
	[ ! -d ${OVERLAY}/usr/share/themes ] && mkdir -p ${OVERLAY}/usr/share/themes
	plain -n "释放主题包${theme}-theme.tgz" | tee -a ${LOG}
       	tar -xzvpf "${theme}-theme.tgz" -C "${OVERLAY}/usr/share/themes/"   2>&1 > /dev/null
	green "完成!" | tee -a ${LOG}
   done
   for icon in ${ICON}; do 
   	if [ ! -f "${icon}-icons.tgz" ]; then
		plain -n "下载图标文件${icon}-icons.tgz" | tee -a ${LOG}
	  	wget -q "${TGZURL}/${icon}-icons.tgz"  2>&1 > /dev/null
		green "完成!" | tee -a ${LOG}
       fi
	[ ! -d ${OVERLAY}/usr/share/icons ] && mkdir -p ${OVERLAY}/usr/share/icons
	plain -n "释放图标文件包${icon}-icons.tgz" | tee -a ${LOG}
       	tar -xzvpf "${icon}-icons.tgz" -C "${OVERLAY}/usr/share/icons/"  2>&1 > /dev/null
	green "完成!" | tee -a ${LOG}
   done
   for cursor in ${CURSOR}; do 
    	if [ ! -f "${cursor}-cursor.tgz" ]; then
   		plain -n "下载鼠标指针文件包${cursor}-cursor.tgz" | tee -a ${LOG}
       		wget -q "${TGZURL}/${cursor}-cursor.tgz"  2>&1 > /dev/null
		green "完成!" | tee -a ${LOG}
	fi
	[ ! -d ${OVERLAY}/usr/share/icons ] && mkdir -p ${OVERLAY}/usr/share/icons
 	plain -n "释放鼠标指针文件包${cursor}-cursor.tgz"
	tar -xzvpf "${cursor}-cursor.tgz" -C "${OVERLAY}/usr/share/icons/"  2>&1 > /dev/null
	green "完成!" | tee -a ${LOG}
   done
   for font in ${EXTRAFONTS}; do 
   	if [ ! -f "${font}-font.tgz" ]; then
		plain -n "下载附加字体包文件${font}-font.tgz" | tee -a ${LOG}
        	wget -q "${TGZURL}/${font}-font.tgz"  2>&1 > /dev/null
		green "完成!" | tee -a ${LOG}
       fi
	[ ! -d ${OVERLAY}/usr/share/fonts/TTF ] && mkdir -p ${OVERLAY}/usr/share/fonts/TTF
	plain -n "释放附加字体包${font}-font.tgz" | tee -a ${LOG}
       	tar -xzvpf "${font}-font.tgz" -C "${OVERLAY}/usr/share/fonts/TTF/"  2>&1 > /dev/null
	green "完成!" | tee -a ${LOG}
   done

   msg2 "输出版本信息 v$(date +%Y%m%d)" | tee -a ${LOG}
   echo "$(date +%Y%m%d)" > "${OVERLAY}/etc/arch-release"

   [ -d "${OVERLAY}/home/arch" ] && chown -R 1001:100 "${OVERLAY}/home/arch" && chmod -R 700 "${OVERLAY}/home/arch"
   [ -d ${OVERLAY}/root ] && chown -R root:root "${OVERLAY}/root" && chmod -R 700 "${OVERLAY}/root"

   green "overlay准备完毕" | tee -a ${LOG}
}
prepare_pacman (){

   # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   if [ "x${1}" != "x" ]; then
	LOG="${1}"
   else
	LOG=${BUILDLOG}/prepare_pacman.log
	[ -f ${LOG} ] && rm -f ${LOG}
   fi

   # 检查宿主系统是不存在pacman，或者archlive.conf强制使用静态编译版pacman

   msg2 "准备安装程序 pacman / pacman.static " | tee -a ${LOG}
   PACMAN="pacman"
   if [ "${USE_STATIC_PACMAN}" = "y" -o "x${host_pacman_version}" = "x" ]; then
	[ "${USE_STATIC_PACMAN}" = "y" ] && plain "配置文件${CONFIG_FILE} 设置为强制使用pacman.static" | tee -a ${LOG}
	[ "x${host_pacman_version}" = "x" ] && plain "宿主系统不是Arch GNU/Linux, 使用pacman.static代替" | tee -a ${LOG}
	PACMAN="${PACMAN_STATIC}"
   fi
   pacman_version=$($PACMAN -V | grep "Pacman" | head -1 | tr -s " " | cut -d " " -f4)
   [ "x${pacman_version}" != "x" ] && green "安装程序准备完成：$PACMAN, 版本 ${pacman_version}" | tee -a ${LOG}
}
prepare_imgroot () {

   msg2 "准备目标镜像根目录结构及启动的相关配置文件" | tee -a ${LOG}
   [ ! -d ${IMGROOT} ] && mkdir -p ${IMGROOT}
   if [ -d ${PROFILE_DIR}/cd-root ]; then
	cp -rf ${PROFILE_DIR}/cd-root/* ${IMGROOT}/
   else
      if [ ! -f cd-root.tgz ]; then
		plain -n "下载Archlive光盘根目录结构文件cd-root.tgz" | tee -a ${LOG}
		wget -q "${TGZURL}/cd-root.tgz"  2>&1 > /dev/null
		green "完成!" | tee -a ${LOG}
      fi
      echo "释放Archlive光盘根目录结构cd-root.tgz" | tee -a ${LOG}
      tar -xzvpf cd-root.tgz -C ${IMGROOT}  2>&1 > /dev/null
   fi
   mkdir -p ${IMGROOT}/${CDNAME}/{base,modules,addons,optional,rootcopy}
   msg2 "目标镜像根目录结构准备完成." | tee -a ${LOG}

}
cmd_prepare (){

   [ ! -d ${WORK_DIR} ] && mkdir -p ${WORK_DIR}

    # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/prepare.log
   [ -f ${LOG} ] && rm -f ${LOG}

   # 检查是否是升级安装
   if [ "${CMD_NAME}" = "install" ] && [ -d ${WORK_DIR} ]; then
	if [ "x$(find ${WORK_DIR} -type f -name "desc" | grep var/lib/pacman/local)" != "x" ]; then
		if [ "${FORCE}" = "n" ]; then
			error "错误: 工作目录'${WORK_DIR}'中已经安装过软件包, 退出." | tee -a ${LOG}
			error "      加入 -f 参数或者archlive.conf中设置FORCE="y"来升级安装. " | tee -a ${LOG}
			exit 1
		else
			green "更新archlive——基于${WORK_DIR}来更新制作archlive." | tee -a ${LOG}
		fi
   	fi
   fi
   msg "开始准备工作..." | tee -a ${LOG}
   prepare_pacman "${LOG}"
   msg2 "创建制作archlive的相关目录" | tee -a ${LOG}
   [ ! -d ${UNION} ] && mkdir -p "${UNION}"    # {WORK_DIR} 一并被创建
   [ ! -d ${BUILDLOG} ] && mkdir -p "${BUILDLOG}"

   if [ "${_CUSTOM_REPO}" = "y" ]; then
	msg2 "建立自定义软件仓..." | tee -a ${LOG}
	# i686 自定义repo
	if [ "$arch" = "i686" -o "$arch" = "dul" ]; then
		if [ "x$i686_REPO_Name" != "x" -a "x$i686_REPO" != "x" ]; then
			plain "在$i686_REPO下建立名为$i686_REPO_Name的i686软件仓"
			custom_repo "i686" "${i686_REPO}" "${i686_REPO_Name}"
			if ! is_in_pacmanconf "${i686_REPO_Name}" "${i686_REPO}" "${PROFILE_DIR}/pacman_i686.conf"; then
				add_customrepo2pacmanconf "${i686_REPO_Name}" "${i686_REPO}" "${PROFILE_DIR}/pacman_i686.conf" "${LOG}"
			fi
			green "i686自定义软件仓创建完成!" | tee -a ${LOG}
		fi
	fi
	# x86_64 自定义repo
	if [ "$arch" = "x86_64" -o "$arch" = "dul" ]; then
		if [ "x${x86_64_REPO_Name}" != "x" -a "x${x86_64_REPO}" != "x" ]; then
			plain "在$x86_64_REPO下建立名为$x86_64_REPO_Name的x86_64软件仓"
			custom_repo "x86_64" "${x86_64_REPO}" "${x86_64_REPO_Name}"
			if ! is_in_pacmanconf "${x86_64_REPO_Name}" "${i686_REPO}" "${PROFILE_DIR}/pacman_x86_64.conf"; then
				add_customrepo2pacmanconf "${x86_64_REPO_Name}" "${x86_64_REPO}" "${PROFILE_DIR}/pacman_x86_64.conf" "${LOG}"
			fi
			green "x86_64自定义软件仓创建完成!" | tee -a ${LOG}
		fi
	fi
	green "自定义软件仓创建完成!" | tee -a ${LOG}
   fi

   prepare_imgroot

   if [ "${USE_OVERLAY}" = "y" ]; then
	prepare_overlay "${LOG}"
   fi

   # 删除下载的 tgz文件
   [ "$DELETE_TGZ" = "y" ] && rm -f ${START_DIR}/*.tgz

   # 软件清单目录
   [ -d ${PACKLIST} ] && rm -R ${PACKLIST}
   mkdir -p ${PACKLIST}
   chmod 777 ${PACKLIST}

   # 导出SP_CUSTOM_DIR特别设置文件（如果有）清单
   if [ "x${SP_CUSTOM_DIR}" != "x" ]; then
	msg2 -n "导出特别设置文件清单..." | tee -a ${LOG}
	find ${SP_CUSTOM_DIR} -type f -name "*" >${PACKLIST}/sp_custom.list
	sed -i "s#${SP_CUSTOM_DIR}/##g" ${PACKLIST}/sp_custom.list
	green "完成！" | tee -a ${LOG}
   fi

   # 如果使用overlay，也使用了SP_CUSTOM_DIR，则将后者合并到前者中
   if [ "${USE_OVERLAY}" = "y" ]; then
	if [ "x${SP_CUSTOM_DIR}" != "x" ]; then
		msg2 -n "合并${SP_CUSTOM_DIR}到${OVERLAY}..." | tee -a ${LOG}
		cat ${PACKLIST}/sp_custom.list | while read file; do
			[ "x$file" = "x" ] && continue
			cp -f ${SP_CUSTOM_DIR}/$file ${OVERLAY}/$file
		done
		green "完成!" | tee -a ${LOG}
	fi
   fi
   msg "mkarchlive准备工作完成" | tee -a ${LOG}
}
function mount_aufs_w () {
   LOG="${2}"
   if [ "${3}" = "quiet" ]; then
	plain -n "将$1以aufs可写模式挂载到${UNION}" >>${LOG}
   else
	plain -n "将$1以aufs可写模式挂载到${UNION}" | tee -a ${LOG}
   fi
   [ "x$(grep $UNION /proc/mounts)" != "x" ] && umount -l ${UNION}
   mount -t aufs -o br:$1=rw aufs ${UNION} >>${LOG}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs可写模式挂载到${UNION}." | tee -a ${LOG}
        usage 1
   else
	if [ "${3}" = "quiet" ]; then
		green "完成." >>${LOG}
	else
		green "完成." | tee -a ${LOG}
	fi
   fi
}

function mount_aufs_r () {
   LOG="${2}"
   if [ "${3}" = "quiet" ]; then
	plain -n "将$1以aufs只读模式挂载到${UNION}" >>${LOG}
   else
	plain -n "将$1以aufs只读模式挂载到${UNION}" | tee -a ${LOG}
   fi
   [ "x$(grep $UNION /proc/mounts)" != "x" ] && umount -l ${UNION}
   [ -f ${UNION}/var/lib/pacman/db.lck ] && rm -f ${UNION}/var/lib/pacman/db.lck
   [ -d ${UNION}/dev ] && rm -rf ${UNION}/dev
   mount -t aufs -o br:$1=ro aufs ${UNION} >>${LOG}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs只读模式挂载到${UNION}." | tee -a ${LOG}
        usage 1
   else
	if [ "${3}" = "quiet" ]; then
		green "完成!" >>${LOG}
	else
		green "完成!" | tee -a ${LOG}
	fi
   fi
}
function remount_aufs_w () {
   LOG="${2}"
   if [ "${3}" = "quiet" ]; then
	plain -n "将$1以aufs可写模式挂载到${UNION}" >>${LOG}
   else
	plain -n "将$1以aufs可写模式挂载到${UNION}" | tee -a ${LOG}
   fi
   mount -t aufs -o remount,add:0:$1=rw aufs ${UNION} >>${LOG}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs可写模式挂载到${UNION}." | tee -a ${LOG}
        usage 1
   else
	if [ "${3}" = "quiet" ]; then
		green "完成!" >>${LOG}
	else
		green "完成!" | tee -a ${LOG}
	fi
   fi
}
function remount_aufs_r () {
   LOG="${2}"
   if [ "${3}" = "quiet" ]; then
	plain -n "将$1以aufs只读模式挂载到${UNION}" >>${LOG}
   else
	plain -n "将$1以aufs只读模式挂载到${UNION}" | tee -a ${LOG}
   fi
   [ -f ${UNION}/var/lib/pacman/db.lck ] && rm -f ${UNION}/var/lib/pacman/db.lck
   [ -d ${UNION}/dev ] && rm -rf ${UNION}/dev
   mount -t aufs -o remount,mod:$1=ro aufs ${UNION} >>${LOG}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs只读模式挂载到${UNION}." | tee -a ${LOG}
        usage 1
   else
	if [ "${3}" = "quiet" ]; then
		green "完成!" >>${LOG}
	else
		green "完成!" | tee -a ${LOG}
	fi
   fi
}

function sync_database () {
   LOG="${1}"

   msg2 "将Arch软件仓库信息更新到${SYNC} ..." | tee -a ${LOG}
   [ ! -d ${SYNC} ] && mkdir -p "${SYNC}"

   [ ! -d ${UNION} ] && mkdir -p "${UNION}"

   [ "x$(grep $UNION /proc/mounts)" != "x" ] && umount -l ${UNION}

   mount_aufs_w "${SYNC}" "${LOG}"

   [ ! -d ${UNION}/var/lib/pacman ] && mkdir -p ${UNION}/var/lib/pacman
   [ -f ${UNION}/var/lib/pacman/db.lck ] && rm -f ${UNION}/var/lib/pacman/db.lck

   plain "现在开始更新软件仓..." | tee -a ${LOG}
   log=${BUILDLOG}/${ARCH}-sync.log
   if [ "${QUIET}" = "y" ]; then
	ARCH=$ARCH $PACMAN -Sy --noprogressbar --noconfirm --config "${PACMANCONF}" -fr "${UNION}" >>$log 2>&1
   else
	echo ""
	ARCH=$ARCH $PACMAN -Sy --noprogressbar --noconfirm --config "${PACMANCONF}" -fr "${UNION}" | tee $log
   fi
   cat ${log} >> ${LOG}
   green "软件仓更新完成!" | tee -a ${LOG}

   remount_aufs_r "${SYNC}" "${LOG}"

   plain -n "导出可用软件包清单到${PACKLIST}/${ARCH}-available.list" | tee -a ${LOG}
   ARCH=$ARCH $PACMAN -Sl >${PACKLIST}/${ARCH}-available.list
   green "完成!" | tee -a ${LOG}

   plain -n "导出软件仓软件组信息到${PACKLIST}/${ARCH}-group_detail.list" | tee -a ${LOG}
   [ -d /tmp/pacman_tmp ] && rm -rf /tmp/pacman_tmp
   mkdir -p /tmp/pacman_tmp/var/lib/pacman/local
   for i in $(ls -A1 ${UNION}/var/lib/pacman/sync); do
	cp -rf ${UNION}/var/lib/pacman/sync/$i/* /tmp/pacman_tmp/var/lib/pacman/local/ 2>/dev/null
   done
   ARCH=$ARCH $PACMAN -Qg -r /tmp/pacman_tmp>${PACKLIST}/${ARCH}-group_detail.list
   rm -rf /tmp/pacman_tmp
   green "完成!" | tee -a ${LOG}
}
function pac_install () {

    if [ ! "$pkgname" ]; then return 1; fi
    [ ! -d $UNION/dev ] && mkdir -p $UNION/dev
    [ ! -c $UNION/dev/console ] && mknod $UNION/dev/console c 5 1 >/dev/null
    [ ! -c $UNION/dev/null ] && mknod $UNION/dev/null c 1 3 >/dev/null
    [ ! -c $UNION/dev/zero ] && mknod $UNION/dev/zero c 1 5 >/dev/null

    while true; do
	LOG="${BUILDLOG}/${ARCH}-${mod}.log"
	echo -e "\n安装$pkgname\n" >> ${LOG}
	if [ "${QUIET}" = "y" ]; then
		ARCH=$ARCH $PACMAN -S -f $pkgname --needed --noconfirm --config "${PACMANCONF}" -r "$UNION" >>${LOG} 2>&1
	else
		echo ""
		ARCH=$ARCH $PACMAN -S -f $pkgname --needed --noconfirm --config "${PACMANCONF}" -r "$UNION" | tee -a ${LOG}
	fi
	case $? in
	   0) (green "软件包${pkgname/-d /} 安装成功! " | tee -a ${LOG} ) && break;;
	    1) 
		pkgname=${pkgname/-d /}
		for pkg in $pkgname; do
			if [ "x$(grep $pkgname ${PACKLIST}/${ARCH}-available.list)" != "x" ]; then
				error "安装$pkgname出错" | tee -a ${LOG}
				cat $log >> ${BUILDLOG}/${mod}-errors.log
				break
			else
				error "现有软件仓中无 $pkgname, 忽略" | tee -a ${LOG}
				break
			fi
		done
		;;
	    255) exit;;
	    esac
	break
    done
}

function pac_remove () {

    if [ ! "$pkgname" ]; then return 1; fi
    while true; do
	LOG=${BUILDLOG}/${mod}.log
	if [ "${QUIET}" = "y" ]; then
		ARCH=$ARCH $PACMAN -R -d -n --noprogressbar --needed --noconfirm --config "${PACMANCONF}" -r "$UNION" $pkgname >>${LOG} 2>&1
	else
		ARCH=$ARCH $PACMAN -R -d -n --noprogressbar --needed --noconfirm --config "${PACMANCONF}" -r "$UNION" $pkgname | tee -a ${LOG}
	fi
	if [ $? -eq 0 ]; then
		green "软件包${pkgname} 卸载成功! " | tee -a ${LOG}
		break
	fi
	break
    done
}

function rm_tmp () {

	LOG=$LOG
	if [ $# -gt 1 ]; then
		for tmp in $@; do
			rm_tmp $tmp
		done
	else
		tmp="$@"
		if [ "x$tmp" != "x" ] && [ -e $tmp ]; then
			rm -rfv $tmp >>${LOG}
		fi
	fi
}

function pac_clean () {

   LOG="${1}"
   msg2 "清理无用文件..." | tee -a ${LOG}

   plain "清理aufs文件系统临时文件.wh.* " | tee -a ${LOG}
   for tmp in "$(find ${WORKDIR} -name .wh..* )"; do rm_tmp $tmp; done
   green "完成!" | tee -a ${LOG}

   if [ "${CMD_NAME}" != "solemodules" ]; then
	plain "删除为宿主系统创建的内核镜像文件..." | tee -a ${LOG}
	source ${INSTROOT}/etc/mkinitcpio.d/kernel*.preset 2>/dev/null
	for tmp in ${default_image} ${fallback_image}; do 
		rm_tmp "${INSTROOT}$tmp"
	done
	green "完成!" | tee -a ${LOG}
   fi

   plain "删除pamcan产生的垃圾文件..." | tee -a ${LOG}
   for tmp in "$(find ${MODULEDIR} -name *.pacnew -name *.pacsave -name *.pacorig)"; do rm_tmp $tmp; done
   green "完成!" | tee -a ${LOG}

   plain "删除图标缓存文件..." | tee -a ${LOG}
   for tmp in "$(find ${MODULEDIR} -type f -name *.cache)"; do rm_tmp $tmp; done
   green "完成!" | tee -a ${LOG}

   plain "删除其它无用文件..." | tee -a ${LOG}
   kill_dirs="dev var/cache/man var/cache/pacman var/log/* var/mail tmp/* initrd"
   for tmp_dir in ${kill_dirs}; do
	for mod in ${MODULES}; do
		rm_tmp ${MODULEDIR}/${mod}/${tmp_dir}
	done
   done
   green "完成!" | tee -a ${LOG}
}
cmd_extramodules_install () {

   # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   if [ "x${1}" != "x" ]; then
	LOG="${1}"
   else
	LOG=${BUILDLOG}/${ARCH}-install_extra_modules.log
	[ -f ${LOG} ] && rm -f ${LOG}
   fi

   msg2 "开始制作附加程序模块——每个模块只有一个软件" | tee -a ${LOG}

    # 初始化文件夹
   [ ! -d ${MODULEDIR} ] && mkdir -p "${MODULEDIR}"
   if [ "${CMD_NAME}" = "solemodules" ]; then
	[ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
	[ -d ${PACKLIST} ] && rm -R ${PACKLIST}
	mkdir -p ${PACKLIST}
	chmod 777 ${PACKLIST}
   fi

   if [ "${RE_EXTRAMODULES}" = "y" ]; then
	plain -n "孤立创建独立模块, 先卸载已经安装的模块..." | tee -a ${LOG}
	umount -l ${UNION}
	green "完成!" | tee -a ${LOG}
	mount_aufs_r "${SYNC}" "${LOG}"
   fi

   # 初始化附加模块安装目录
   [ -d ${EXTRA_MODULES_INS_DIR} ] && rm -rf ${EXTRA_MODULES_INS_DIR} && mkdir -p ${EXTRA_MODULES_INS_DIR}
   # 如果只是独立制作模块需要单独更新软件仓库信息
   if [ "${CMD_NAME}" = "solemodules" ]; then
	sync_database "${LOG}"
   fi

   [ -f ${EXTRA_MODULE_LIST} ] && rm -f ${EXTRA_MODULE_LIST}
   for mod in $EXTRAMODULES; do
	[ ! -d ${EXTRA_MODULES_INS_DIR}/${mod} ] && mkdir -p ${EXTRA_MODULES_INS_DIR}/${mod}
	remount_aufs_w "${EXTRA_MODULES_INS_DIR}/${mod}" "${LOG}"
	[ "x$mod" = "x" ] && continue
	pkgname="-d $mod"
	pac_install
	#再只读挂载
	remount_aufs_r "${EXTRA_MODULES_INS_DIR}/${mod}" "${LOG}"
   	# 导出已经安装的软件清单(独立模块，含版本信息)
	$PACMAN -Q -r "${EXTRA_MODULES_INS_DIR}/${mod}" >> ${EXTRA_MODULE_LIST}
   done

   msg2 "附加模块 $(echo ${EXTRAMODULES} | tr -s "\n" " ") 安装完成." | tee -a ${LOG}

   # 卸载UNION
   msg2 "卸载aufs件系统 ${UNION}." | tee -a ${LOG}
   umount -l ${UNION}
   for tmp in "$(find ${WORKDIR} -name .wh..* )"; do rm_tmp $tmp; done
}

function get_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中需要检测依赖关系的软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {dep_pkg=""}{if ($1 !~ /^#+/) {if (NF == 1) {dep_pkg=dep_pkg " " $1}}}END {print dep_pkg}' $1)
}
function get_d_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中无需检测依赖关系的软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {nodep_pkg=""}{if ($1 !~ /^#+/) { if (NF == 2) {nodep_pkg=nodep_pkg " " $2}}}END {print nodep_pkg}' $1)
}
function get_all_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中所有软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {all_pkg=""}{if ($1 !~ /^#+/) { {all_pkg=nodep_pkg " " $1" "$2}}}END {print all_pkg}' $1)
}

cmd_install ()
{

    # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/${ARCH}-install.log
   [ -f ${LOG} ] && rm -f ${LOG}

   [ -d ${UNION}/dev ] && rm -rf ${UNION}/dev
   [ ! -d ${PACKLIST} ] && mkdir -p ${PACKLIST}

   echo ""
   msg "开始进行Archlive($ARCH)的制作..." | tee -a ${LOG}
   msg2 "开始将$LISTDIR里面的软件安装/更新到对应模块文件夹" | tee -a ${LOG}
    # 更新软件仓库信息
   sync_database "${LOG}"
   [ -f ${PACKLIST}/${ARCH}-updated.list ] && rm -f ${PACKLIST}/${ARCH}-updated.list

   for mod in ${MODULES}; do
	echo | tee -a ${LOG}
	msg2 "现在安装模块 $mod ..." | tee -a ${LOG}
	echo | tee -a ${LOG}
	#如果模块名以#开头则忽略
	#[ "$(case $mod in \#*) echo 0 ;; esac)" ] && continue  #不再需要，已经整理过
	[ ! -d ${MODULEDIR}/${mod} ] && mkdir -p ${MODULEDIR}/${mod}
	remount_aufs_w "${MODULEDIR}/${mod}" "${LOG}"
	
	plain -n "将模块软件清单整理后输出（去除被#注释的）" | tee -a ${LOG}
	local old_list new_list
	old_list="${PROFILE_DIR}/$LISTDIR/${mod}.list"
	new_list="${PACKLIST}/${ARCH}-${mod}.new"
	[ "x$(tail -1 ${old_list})" = "x" ] || (echo >>"${old_list}")
 	cat "${old_list}" | sed -r "s/#.*//g" | sed -r "/^$/d" >${new_list}
	green "完成!" | tee -a ${LOG}

	msg2 -n "检查 ${mod} 软件清单中软件是否存在于设定的软件仓中..." | tee -a ${LOG}
	cat ${new_list} | while read pkgname; do
		pkgname=${pkgname#-d }
		if grep " $pkgname " ${PACKLIST}/${ARCH}-available.list >/dev/null; then
			continue
		elif grep "$pkgname " ${PACKLIST}/${ARCH}-group_detail.list >/dev/null; then
			continue
		else
			warn "模块 ${mod} 中指定的软件 $pkgname 无法从当前设定的软件仓中找到。" | tee -a ${LOG}
		fi
	done
	green "完成!" | tee -a ${LOG}

	# 如果已经存在对应模块，则将对应软件包及版本信息输出到清单并根据已经安装的软件升级
	pacman_local_data=${MODULEDIR}/${mod}/var/lib/pacman/local
	if [ -d ${pacman_local_data} ] && [ "x$(find ${pacman_local_data} -type f -name "desc")" != "x" ]; then
		$PACMAN -Q -r ${MODULEDIR}/${mod} > ${PACKLIST}/${ARCH}-${mod}.old | tee -a ${LOG}
		green "已安装的程序及版本信息已导出到文件${PACKLIST}/${ARCH}-${mod}.old" | tee -a ${LOG}
		$PACMAN -Su -f --needed --noconfirm --config "${PACMANCONF}" -fr "${UNION}" >/dev/null
		green "已有程序升级完成." | tee -a ${LOG}

		# 安装清单中需要的但没有被安装的软件包

		# 首先将需要安装的清单中软件组挑出来, 替换为实际软件名
		[ -f ${PACKLIST}/${ARCH}-${mod}.new.tmp ] && rm -f ${PACKLIST}/${ARCH}-${mod}.new.tmp
		cp -f ${PACKLIST}/${ARCH}-${mod}.new ${PACKLIST}/${ARCH}-${mod}.new.tmp
		cat ${PACKLIST}/${ARCH}-${mod}.new | while read pkgname; do
			pkgname=${pkgname#-d }
			if grep " $pkgname " ${PACKLIST}/${ARCH}-available.list >/dev/null; then continue; fi
			grep "^$pkgname " ${PACKLIST}/${ARCH}-group_detail.list | awk '{print $2}' >>${PACKLIST}/${ARCH}-${mod}.new.tmp
			cat ${PACKLIST}/${ARCH}-${mod}.new.tmp | sed "s|^base$||g" | sed -r "/^$/d" >${PACKLIST}/${ARCH}-${mod}.new.tmp.1
			cp -f ${PACKLIST}/${ARCH}-${mod}.new.tmp.1 ${PACKLIST}/${ARCH}-${mod}.new.tmp
		done

		# 比较新就清单执行相应动作
		# 无-d选项的
		newpkgname=$(awk 'NR==FNR{a[$1];b[$2]}NR>FNR{if (!($2 in a)) {if (!($1 in a)) {print $0}}}' ${PACKLIST}/${ARCH}-${mod}.old ${PACKLIST}/${ARCH}-${mod}.new.tmp | grep -v "\-d")
		for pkgname in ${newpkgname}; do
			[ "x$pkgname" = "x" ] && continue
			if $PACMAN -Q $pkgname -r ${UNION} 2>&1 >/dev/null;then continue; fi
			plain "$pkgname 是新添加的(需要检测依赖关系)，需要安装..." | tee -a ${LOG}
			pac_install
		done
		# 有 -d 选项的
		newpkgname=$(awk 'NR==FNR{a[$1];b[$2]}NR>FNR{if (!($2 in a)) {if (!($1 in a)) {print $0}}}' ${PACKLIST}/${ARCH}-${mod}.old ${PACKLIST}/${ARCH}-${mod}.new.tmp | grep "\-d")
		for pkgname in ${newpkgname}; do
			[ "x$pkgname" = "x" ] && continue
			if $PACMAN -Q $pkgname -r ${UNION} 2>&1 >/dev/null;then continue; fi
			plain "$pkgname 是新添加的(需要检测依赖关系)，需要安装..." | tee -a ${LOG}
			pac_install
		done
		# 删除已经安装的多余的软件
		# 暂时先不卸载了！ 依赖关系！。。。
		#pkgname=$(awk 'BEGIN {OFS="\t"}NR==FNR{a[$0];b[$2]}NR>FNR{if (!($1 in b)) {if (!($1 in a)) {print $1}}}' ${PACKLIST}/${ARCH}-${mod}.new.tmp ${PACKLIST}/${ARCH}-${mod}.old)
		#if [ "x$pkgname" != "x" ]; then plain "$pkgname 在新清单中没有，需要删除..."; pac_remove; fi
	fi
	if [ "x$(find ${MODULEDIR}/${mod} -type f -name "desc")" = "x" ]; then
		touch ${PACKLIST}/${ARCH}-${mod}.old
		if [ "${QUICK_INSTALL}" = "y" ]; then
			get_d_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.list
			if [ "x${pkgname}" != "x" ]; then
				pkgname="-d ${pkgname}"
				pac_install
			fi
			get_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.list
			[ "x${pkgname}" != "x" ] && pac_install
		else
	        	cat  "${PACKLIST}/${ARCH}-${mod}.new" | while read pkgname; do
				[ "x$pkgname" = "x" ] && continue
				echo "$pkgname" >>${PACKLIST}/${ARCH}-${mod}.order
				pac_install
	        	done
		fi
        	if [ -e "${PROFILE_DIR}/$LISTDIR/${mod}.removelist" ]; then
			if [ "${QUICK_INSTALL}" = "y" ]; then
				get_all_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.removelist
				if [ "x${pkgname}" != "x" ]; then
					pkgname="-d ${pkgname}"
					pac_remove
				fi
			else
	            		cat "${PROFILE_DIR}/$LISTDIR/${mod}.removelist" | grep -v "^#" | while read pkgname; do pac_remove; done
			fi
        	fi
	fi

	#[ -e "${UNION}/etc/ld.so.conf" ] && chroot $UNION ldconfig
	[ -f ${MODULEDIR}/${mod}/etc/sudoers ] && chmod 0440 ${MODULEDIR}/${mod}/etc/sudoers

	msg2 -n "导出最新模块已安装软件清单..." | tee -a ${LOG}
	$PACMAN -Q -r ${MODULEDIR}/${mod} > ${PACKLIST}/${ARCH}-mod_${mod}.new
	green "完成!" | tee -a ${LOG}

	[ -f ${PACKLIST}/${ARCH}-updated.list ] && rm -f ${PACKLIST}/${ARCH}-updated.list
	if [ -f ${PACKLIST}/${ARCH}-${mod}.old ] && [ "x$(cat ${PACKLIST}/${ARCH}-${mod}.old)" != "x" ]; then
		msg2 -n "此次为升级安装，查看更新内容..." | tee -a ${LOG}
		diff -ruNa ${PACKLIST}/${ARCH}-${mod}.old ${PACKLIST}/${ARCH}-mod_${mod}.new | grep "^[-,+][a-zA-Z]" > ${PACKLIST}/${ARCH}-${mod}.list
		if [ "x$(cat ${PACKLIST}/${ARCH}-${mod}.list)" != "x" ]; then
			echo "${mod} 模块更新内容(-表示删除的包，+表示新加入的包)" >>${PACKLIST}/${ARCH}-updated.list
			cat ${PACKLIST}/${ARCH}-${mod}.list >>${PACKLIST}/${ARCH}-updated.list
		fi
		green "完成!" | tee -a ${LOG}
	fi

	if [ -f ${MODULEDIR}/${mod}/etc/pacman.conf ]; then
		msg2 -n "拷贝对应Arch的源配置文件到目标系统..." | tee -a ${LOG}
		if [ "${USE_OVERLAY}" = "y" ]; then
			conf_target="${OVERLAY}"; 
		else
			conf_target="${MODULEDIR}/${mod}"
		fi
		[ -d ${conf_target}/etc/pacman.d ] || mkdir -p ${conf_target}/etc/pacman.d

		rm -f ${MODULEDIR}/${mod}/etc/pacman.conf
		rm -f ${MODULEDIR}/${mod}/etc/pacman.d/mirrorlist
		#cp -f ${PACMANCONF} ${conf_target}/etc/pacman.conf
		#cp -f ${PROFILE_DIR}/mirrorlist.${ARCH} ${conf_target}/etc/pacman.d/mirrorlist

		cp -f ${PACMANCONF} ${conf_target}/etc/pacman_${ARCH}.conf
		cp -f ${PROFILE_DIR}/mirrorlist.${ARCH} ${conf_target}/etc/pacman.d/mirrorlist.${ARCH}
		sed -i "s%^Include =.*%Include = /etc/pacman.d/mirrorlist.${ARCH}%g" ${conf_target}/etc/pacman_${ARCH}.conf
		sed -i "s%.*CacheDir.*%\#CacheDir    = /var/cache/pacman/pkg/%g" ${conf_target}/etc/pacman_${ARCH}.conf

		green "完成!" | tee -a ${LOG}
	fi

	if [ -f ${MODULEDIR}/${mod}/etc/rc.conf ]; then
		# 备份Arch原始启动关机脚本，以便Larchin安装
		plain -n "备份Arch原始启动关机脚本，以便Larchin安装" | tee -a ${LOG}
		for larchsavefile in ${MODULEDIR}/${mod}/etc/{rc.sysinit,rc.shutdown,rc.local}; do
			cp -f ${larchsavefile} ${larchsavefile}.larchsave
		done
		green "完成!" | tee -a ${LOG}
  	fi

	# 当glibc 已经安装则检查是否有特别定制的locale.gen(可以在overlay下也可以在${SP_CUSTOM_DIR}下), 有则产生locale文件
	if [ -d ${MODULEDIR}/${mod}/var/lib/pacman/local ] && \
		[ "x$(ls ${MODULEDIR}/${mod}/var/lib/pacman/local | grep "glibc-")" != "x" ]; then
		if [ "${USE_OVERLAY}" = "y" ]; then
			locale_gen_file="${OVERLAY}/etc/locale.gen"
		else
			locale_gen_file="${SP_CUSTOM_DIR}/etc/locale.gen"
		fi
		if [ -f "${locale_gen_file}" ]; then
			cp -f ${locale_gen_file} $UNION/etc/
			plain -n "根据定制的locale.gen文件生成locale文件"
			chroot $UNION locale-gen
			green "完成!" | tee -a ${LOG}
		fi
	fi

	# 如果没有使用Overlay，则直接合并到目标系统(每个模块中都有)
	if [ "${USE_OVERLAY}" != "y" ]; then
		plain -n "没有选择使用Overlay, 将${SP_CUSTOM_DIR}中文件合并到目标系统中"
		cat ${PACKLIST}/sp_custom.list | while read file; do
			[ "x$file" = "x" ] && continue
			cp -f ${SP_CUSTOM_DIR}/$file ${UNION}/
		done
		green "完成!" | tee -a ${LOG}
	fi

	# 更新内核模块依赖关系
	if [ -d ${MODULEDIR}/${mod}/lib/modules ]; then
		if [ $(ls ${UNION}/lib/modules | wc -l) -ge 2 ]; then
			error "目标系统中内核模块有两个或者两个以上的版本" | tee -a ${LOG}
			exit 1
		fi
		local mod_file kernel_ver
		mod_file="${UNION}/lib/modules/*/modules.dep"
		kernel_ver="$(basename $(dirname ${mod_file}))"
		depmod -a -b ${UNION} {kernel_ver}
	fi

	# 重新只读挂载以进行下一个模块
	remount_aufs_r "${MODULEDIR}/${mod}" "${LOG}"
   done

   # 引入全局变量 SUPPORT_ESSENTIAL_MODULES 以免每个含有内核模块的均检测, 另：如果已经编入到内核而不作为模块则不需检测
   # 检测包含内核的模块中，文件系统模块是否齐全
   if [ "${SUPPORT_ESSENTIAL_MODULES}" = "n" ] && [ -d ${MODULEDIR}/${mod}/lib/modules ] && [ "x$(find ${UNION}/lib/modules -type f -name "*.ko")" != "x" ]; then
	msg2 -n "检查目标系统是否有足够的文件系统模块: aufs,squashfs等..." | tee -a ${LOG}

	local fs_system
	# 检查核心模块
	fs_system="aufs squashfs"
	case ${ZIP_MODE} in 1|2) fs_system="${fs_system} sqlzma unlzma";; esac
	for fs_type in ${fs_system}; do
		#if [ "x$(find ${MODULEDIR}/${mod}/lib/modules -type f -name "${fs_type}.ko")" = "x" ]; then
		if [ "x$(grep "${fs_type}.ko" ${mod_file})" = "x" ]; then
				error "目标系统不包含必须的${fs_type}文件系统模块, 请修改${PROFILE_DIR}/$LISTDIR/${mod}.list" | tee -a ${LOG}
				error "如果${fs_system}文件系统已经编入内核而不是作为模块，则将${CONFIG_FILE}中KERNEL_KEY_FS_INCLUDED值改为y" | tee -a ${LOG}
				exit 1
		fi
	done
	SUPPORT_ESSENTIAL_MODULES="y"
	green "完成!" | tee -a ${LOG}
   fi

   msg2 -n "导出已经安装的软件清单..." | tee -a ${LOG}
   $PACMAN -Q -r ${UNION} > ${PKGFILE}
   green "完成!" | tee -a ${LOG}

   #如果附加程序模块已经包含在程序清单中则不另外安装制作，除非archlive.conf中特别设置
   if [ "x$EXTRAMODULES" != "x" ]; then
	if [ "${RE_EXTRAMODULES}" = "y" ]; then
		cmd_extramodules_install "${LOG}"
	else
		local noinstall=""
		$PACMAN -Q -r ${UNION} > ${PKGFILE}
		for package in $EXTRAMODULES; do
			if grep "^$pkgname " ${PKGFILE} >/dev/null; then
				continue
			else
				noinstall="$noinstall $pkgname"
			fi
		done
		if [ "x$noinstall" ! = "x" ]; then
			EXTRAMODULES=$noinstall
			cmd_extramodules_install "${LOG}"
		fi
	fi
   fi

   # 卸载UNION
   if [ "x$(grep $UNION /proc/mounts)" != "x" ]; then
	msg2 "卸载aufs件系统 ${UNION}." | tee -a ${LOG}
	umount -l ${UNION}
	for tmp in "$(find ${WORKDIR} -name .wh..* )"; do rm_tmp $tmp; done
   fi

   # 清理不需要的文件
   pac_clean "${LOG}"
}

# $1 源文件/目录 source file/directory
# $2 基于目录basedir (trim $2 from $1)
# $3 目标目录  target directory
# $4 日志 log
mv_to () {

    local source basedir target log i
    source=$1
    basedir=$2
    target=$3
    log=$4
    if [ -e "$source" ]; then
	if [ -d $target/${source#$basedir} ]; then
		for i in $(ls -A1 $source); do
			[ "x$i" = "x" ] && continue
			mv_to "$source/$i" "$basedir" "$target" "$log"
		done
	else
		target_dir="$(dirname "$target/${source#$basedir}")"
		[ -d "${target_dir}" ] || (mkdir -p "${target_dir}")
		mv -fv "$source" "$target/${source#$basedir}" >>"$log"
		return 0
	fi
    fi
}

# 模块清理，删除指定的文件
cmd_clean () {

   # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/${ARCH}-clean_files.log
   [ -f ${LOG} ] && rm -f ${LOG}

   plain "删除指定的文件夹..." | tee -a ${LOG}
   for tmp_dir in ${DELDIR}; do
	for mod in ${MODULES}; do
		mv_to "${MODULEDIR}/${mod}/${tmp_dir}" "${MODULEDIR}/${mod}" "${CLEANED_BACKUP_DIR}" "$LOG"
	done
   done
   green "完成!" | tee -a ${LOG}

   if [ "${CUT_LOCALE}" = "y" ]; then
	plain "删除${REMAIN_LOCALE}外的语言文件、帮助文件、X语言文件..." | tee -a $LOG
	clean_target_locales="${PACKLIST}/${ARCH}-clean_target_locales"
	for mod in ${MODULES}; do
		clean_target="${PACKLIST}/${ARCH}-clean_target_locales_$mod"
		localedir=$(find ${MODULEDIR}/${mod} -type d -name "locale")
		if [ -d ${MODULEDIR}/${mod}/usr/share/man ]; then
			localedir="$localedir ${MODULEDIR}/${mod}/usr/share/man"
		fi
		for dir in $localedir; do
			[ "x$(ls -A1 $dir 2>/dev/null)" = "x" ] && continue
			find $dir/* -maxdepth 0 -type d >>${clean_target}
		done
		find ${MODULEDIR}/${mod} -type f -name "*.qm" >>${clean_target}
		find ${MODULEDIR}/${mod} -type f -name "*.ts" >>${clean_target}

		cat ${clean_target} | while read tmp; do
			[ "x$tmp" = "x" ] && continue
			keep="n"
			case $tmp in
				*/man/man*) keep="y";;
				*/locale/*|*/man/*)
					for i in ${REMAIN_LOCALE}; do
						case $tmp in */$i*) keep="y" && break;; esac
					done
					;;
				*.ts|*.qm)
					for i in ${QT_KEEP_LOCALE}; do
						case $tmp in */*_$i.*) keep="y" && break;; esac
					done
					;;
			esac
			[ "$keep" != "y" ] && (mv_to "$tmp" "${MODULEDIR}/${mod}" "${CLEANED_BACKUP_DIR}" "$LOG")
		done
        	cat $clean_target >>${clean_target_locales}
		rm -f $clean_target
	done
   	green "完成!" | tee -a $LOG
   fi

   if [ "${_move_devel}" = "y" ]; then
	msg2 "整理编译所需库文件、源码等(运行时无需)..." | tee -a ${LOG}
	local target mod file dir file_type
	if [ "x${_move_devel_target}" != "x" ]; then
		target="${MODULEDIR}/${_move_devel_target}"
	else
		target="${WORK_DIR}/mkarchlive_tmp"
		[ -d "$target" ] && rm -rf "$target" && mkdir -p "$target"
	fi
	for mod in ${MODULES}; do
		[ "${_move_devel_target}" = "${mod}" ] && continue
		for dir in ${_move_devel_dir}; do
			[ "x$dir" = "x" ] && continue
			#plain "将${MODULEDIR}/${mod}/$dir下内容移到$target..." | tee -a ${LOG}
			mv_to "${MODULEDIR}/${mod}/$dir" "${MODULEDIR}/${mod}" "$target" "${LOG}"
			#green "完成!" | tee -a ${LOG}
		done
		for file_type in ${_move_devel_file_type}; do
			[ "x$file_type" = "x" ] && continue
			#plain "将${MODULEDIR}/${mod}/下扩展名为${file_type}的文件移动到$target..." | tee -a ${LOG}
			for file in $(find ${MODULEDIR}/${mod} -type f -name "*${_move_devel_file_type}"); do
				[ "x$file" = "x" ] && continue
				mv_to "$file" "${MODULEDIR}/${mod}" "$target" "${LOG}"
			done
			#green "完成!" | tee -a ${LOG}
		done			
	done
	green "完成!" | tee -a ${LOG}
   fi
   if [ "${_move_help}" = "y" ]; then
	msg2 "整理帮助文件(一般运行无需)..." | tee -a ${LOG}
	local target mod file dir file_type
	if [ "x${_move_help_target}" != "x" ]; then
		target="${MODULEDIR}/${_move_help_target}"
	else
		target="${CLEANED_BACKUP_DIR}"
		#[ -d "$target" ] && rm -rf "$target" && mkdir -p "$target"
	fi
	for mod in ${MODULES}; do
		[ "${_move_help_target}" = "${mod}" ] && continue
		for dir in ${_move_help_dir}; do
			[ "x$dir" = "x" ] && continue
			#plain "将${MODULEDIR}/${mod}/$dir下内容移到$target..." | tee -a ${LOG}
			mv_to "${MODULEDIR}/${mod}/$dir" "${MODULEDIR}/${mod}" "$target" "${LOG}"
			#green "完成!" | tee -a ${LOG}
		done
	done
	green "完成!" | tee -a ${LOG}
   fi
}

function mksquashfs_module () {
   LOG=${3}
   plain "将${1} 用 $MKSQUASHFS 进行压缩..." | tee -a ${LOG}
   [ -d ${1}/usr/share/fonts ] && chmod 755 ${1}/usr/share/fonts
   [ -d ${1}/etc/fonts ] && chmod 755 ${1}/etc/fonts
   OPTION="-noappend ${OPTION}"
   if [ "${QUIET}" = "y" ]; then
	   $MKSQUASHFS ${1} ${2} ${OPTION} >> ${LOG}
   else
	$MKSQUASHFS ${1} ${2} ${OPTION} | tee -a ${LOG}
   fi
   chmod 0755 ${2} | tee -a ${LOG}
   green "完成!" | tee -a ${LOG}
}
cmd_extramodules_squash () {

   [ ! -d ${WORK_DIR} ] && (warn "工作目录还不存在，请先 install..." && exit 1)

   # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   if [ "x${1}" != "x" ]; then
	LOG="${1}"
   else
	LOG=${BUILDLOG}/${ARCH}-create_extra_sqfs_modules.log
	[ -f ${LOG} ] && rm -f ${LOG}
   fi

   plain "压缩独立程序模块..." | tee -a ${LOG}
   if [ "${RE_EXTRAMODULES}" = "y" ]; then
	start=$(date +%s)
   fi
   [ ! -d ${EXTRA_MODULES_TARGET} ] && mkdir -p ${EXTRA_MODULES_TARGET}
   for module_dir in $(ls ${EXTRA_MODULES_INS_DIR}); do
	source_dir="${EXTRA_MODULES_INS_DIR}/${module_dir}"
	target_file="${EXTRA_MODULES_TARGET}/${ARCH}-$(ls ${EXTRA_MODULES_INS_DIR}/${module_dir}/var/lib/pacman/local).${EXT}"
	mksquashfs_module "${source_dir}" "${target_file}" "${LOG}"
   done
   if [ "${RE_EXTRAMODULES}" = "y" ]; then
	green "独立模块($ARCH)在 $(echo $start $(date +%s) | awk '{ printf "%0.2f",($2-$1)/60 }') 分钟内完成压缩." | tee -a ${LOG}
   fi
}

cmd_re_mount_all ()
{
    # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/re_mount_all.log
   [ -f ${LOG} ] && rm -f ${LOG}

   mount_aufs_w "${SYNC}" "${LOG}" "quiet"
   for mod in ${MODULES}; do
	remount_aufs_w "${MODULEDIR}/${mod}" "${LOG}" "quiet"
   done
}

check_kernel()
{
   basedir=""
   kernelver=""
   LOG="${1}"

   # KER_VERSION_FILE 值由archlive.conf指定
    
   preset_file="$(basename ${KER_VERSION_FILE})"
   #basedir="$MODULEDIR/${KERNEL_MOD}"
   #if [ ! -d $basedir ]; then
	#error "${WORK_DIR}下没有安装系统或者配置文件${CONFIG_FILE}中指定的${KERNEL_MOD}模块未被开启"
	#usage 1
   #fi

   cmd_re_mount_all
   basedir="$UNION"

   # 不采用pacman解决问题
   kernel_list_file="$(grep "modules.dep.bin" `find $basedir/var/lib/pacman/local` | cut -d ":" -f1)"
   kernel_desc_file="$(dirname ${kernel_list_file})/desc"
   if [ ! -f "${kernel_desc_file}" ]; then
	error "${KERNEL_MOD}模块中没有安装内核"
	usage 1
   fi

   if [ "$(grep "${preset_file}" "${kernel_list_file}")" = "x" ]; then
	error "目标系统无安装内核或者内核安装出错..." | tee -a ${LOG}
	usage 1
   fi

   kernelver=$(basename $(dirname $(grep "modules.dep.bin" ${kernel_list_file})))
   ker_pkgname=$(sed -n '2p' ${kernel_desc_file})
   ker_pkg_ver=$(sed -n '5p' ${kernel_desc_file})

   plain "目标系统内核程序名为 ${ker_pkgname}, 版本为${ker_pkg_ver}" | tee -a ${LOG}
   plain "目标系统内核模块安装于 $basedir 版本为$kernelver" | tee -a ${LOG}
}

# 将工作目录下的overlay压缩为sqfs文件系统包
# $1   LOG
cmd_overlay_sqfs () {
	LOG=$1
	msg2 "创建附加设置模块z-overlay.${EXT}..." | tee -a ${LOG}
	OVERLAY="${WORK_DIR}/overlay"
	[ ! -d ${IMGROOT}/${CDNAME}/modules ] && mkdir -p ${IMGROOT}/${CDNAME}/modules
	mksquashfs_module  "${OVERLAY}" "${IMGROOT}/${CDNAME}/modules/z-overlay.${EXT}" "${LOG}"
	green "Overlay模块已经成功创建到${IMGROOT}/${CDNAME}/modules目录下." | tee -a ${LOG}
}

cmd_squash () {

   [ ! -d ${WORK_DIR} ] && (warn "工作目录还不存在，请先 install..." && exit 1)

   # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/${ARCH}-create_sqfs_modules.log
   [ -f ${LOG} ] && rm -f ${LOG}

   if [ ! -d ${MODULEDIR} ]; then
	error "${WORK_DIR}下还没有安装模块，请先执行 install命令." | tee -a ${LOG}
	usage 1
   fi

   msg "创建squash模块..." | tee -a ${LOG}
   start=$(date +%s)

   msg2 "更新内核模块依赖关系..." | tee -a ${LOG}
   check_kernel ${LOG}
   depmod -a -b ${basedir} ${kernelver} 2>&1 >/dev/null
   green "内核模块依赖关系更新完成." | tee -a ${LOG}

   #squashfs压缩的基本模块存放位置 比如 i686-0_000_core.sqfs
   for module_dir in $MODULES; do
	moduleplace="${IMGROOT}/${CDNAME}/base"
	case ${module_dir} in [1-9]_*) moduleplace="${IMGROOT}/${CDNAME}/modules";; esac
	source_dir="${MODULEDIR}/${module_dir}"
	target_file="${moduleplace}/${ARCH}-$(basename ${module_dir}).${EXT}"

	# 如果不存在制作好的模块或者有更新则创建模块  ${PACKLIST}/${ARCH}-${module_dir}.list存放对应模块的更新详情
	if [ ! "$(find $IMGROOT/$CDNAME -name $(basename  ${target_file}))" -o "x$(cat ${PACKLIST}/${ARCH}-${module_dir}.list)" != "x" ]; then
		mksquashfs_module "${source_dir}" "${target_file}" "${LOG}"
	fi
   done

   if [ "${USE_OVERLAY}" = "y" ] && [ -d ${WORK_DIR}/overlay ]; then cmd_overlay_sqfs; fi

   #如果附加程序模块已经包含在程序清单中则不另外安装制作
   [ "${RE_EXTRAMODULES}" != "y" ] && cmd_extramodules_squash "${LOG}"

   minutes=$(echo $start $(date +%s) | awk '{ printf "%0.2f",($2-$1)/60 }')
   green "$ARCH模块在 $minutes 分钟内完成创建." | tee -a ${LOG}
}

cmd_boot_kernel_image () {

   [ ! -d ${WORK_DIR} ] && (warn "工作目录还不存在，请先 install..." && exit 1)

   # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/${ARCH}-create_boot_image.log
   [ -f ${LOG} ] && rm -f ${LOG}

   msg "准备archlive内核及内核镜像" | tee -a ${LOG}

   # 判断archlive内核镜像配置文件是否存在
   [ ! -e "${CPIOCONFIG}" ] && error "错误: live系统启动内核镜像配置文件 '${CPIOCONFIG}' 不存在, 退出." && usage 1

   check_kernel "${LOG}"

   [ "x$kernelver" = "x" ] && error "目标系统内核安装有误，或者内核程序包有问题..." && exit 1

   msg2 "更新版本信息" | tee -a ${LOG}
   boot_version="$(date +%Y%m%d)"
   sed -i "s%boot_version=.*%boot_version=Ver.$boot_version%g" $(dirname $MKINITCPIO)/initcpio/liblinuxlive
   chmod +x $(dirname $MKINITCPIO)/initcpio/init

   msg2 -n "拷贝内核文件${KER_FILE}..." | tee -a ${LOG}
   # KER_FILE 在配置文件archlive.conf中定义，默认为vmlinuz26
   [ ! -d "${IMGROOT}/${CDNAME}/boot" ] && mkdir -p "${IMGROOT}/${CDNAME}/boot"
   [ -f "${IMGROOT}/${CDNAME}/boot/${KER_FILE}" ]
   right_ker_file="n" 
   case $(grep "boot/${KER_FILE}" "$(dirname ${kernel_desc_file})/files") in boot/$KER_FILE) right_ker_file="y";; esac
   [ "${right_ker_file}" = "n" ] && error "目标系统的内核文件名不是${KER_FILE}，请再次检查配置文件和目标系统的内核程序包..." | tee -a ${LOG} && exit 1
   [ -f ${basedir}/boot/${KER_FILE} ] && cp -f "${basedir}/boot/${KER_FILE}" "${IMGROOT}/${CDNAME}/boot/$ARCH.ker"

   [ -f "${IMGROOT}/${CDNAME}/boot/$ARCH.ker" ] && green "完成." | tee -a ${LOG}


   msg2 -n "重置启动内核镜像启动标的..." | tee -a ${LOG}
    # 启动过程中根据此标的查找live系统的位置
   sed -i "s%export LIVECDNAME=.*%export LIVECDNAME=\"${CDNAME}\"%g" "$(dirname $MKINITCPIO)/initcpio/liblinuxlive"
   green "完成." | tee -a ${LOG}

   msg2 "创建${CDNAME}系统启动的内核镜像..." | tee -a ${LOG}
	plain "配置文件 ${CPIOCONFIG} " | tee -a ${LOG}
	plain "基于目录 ${basedir} " | tee -a ${LOG}
	plain "内核版本 ${kernelver} " | tee -a ${LOG}

   plain -n "创建启动内核镜像可能需要好几分钟时间，请稍候..."
   [ -f ${BUILDLOG}/${ARCH}-initrd.filelist ] && rm -f ${BUILDLOG}/${ARCH}-initrd.filelist
   [ -f /tmp/archlive-boot.log ] && rm -f /tmp/archlive-boot.log
   ARCH=$ARCH sh $MKINITCPIO -c "${CPIOCONFIG}" -b "${basedir}" -k "${kernelver}" -g \
		"${IMGROOT}/${CDNAME}/boot/$ARCH.img" -s ${BUILDLOG}/${ARCH}-initrd.filelist >> ${LOG}
   if [ $? -ne 0 ]; then
	error "错误: 内核镜像创建失败..." | tee -a ${LOG}
	usage 1
   fi
   cat /tmp/archlive-boot.log >>${LOG}
   green "完成！" | tee -a ${LOG}
   umount -l $UNION
   for tmp in "$(find ${WORKDIR} -name .wh..* )"; do rm_tmp $tmp; done
}

cmd_img () {

   [ ! -d ${WORK_DIR} ] && (warn "工作目录还不存在，请先 install..." && exit 1)

    # 日志文件
   [ -d ${BUILDLOG} ] || mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/final_image.log
   [ -f ${LOG} ] && rm -f ${LOG}

   mkisofs_version=$(mkisofs --version | head -1| cut -d " " -f2)
   [ "x${mkisofs_version}" = "x" ] && (error "宿主系统没有mkisofs程序，请先安装cdrkit" && exit 1)

   msg "准备制作镜像所需要的程序模块..." | tee -a ${LOG}

    #判断${IMGROOT}下的模块是否是需要的——由${CONFIG_FILE}: archlive.conf定义
   
   msg2 "清理不需要的模块到${NO_NEED_MODULES_DIR}下... " | tee -a ${LOG}
   [ ! -d ${NO_NEED_MODULES_DIR} ] && mkdir -p ${NO_NEED_MODULES_DIR}
   for module_file in $(find ${IMGROOT} -name "*.sqfs" -o -name "*.lzm"); do
	needed="n"
	#plain "检查 $(basename $module_file)"
	case ${module_file} in */z-overlay.${EXT}) case ${USE_OVERLAY} in y) needed="y" && continue;; esac;; esac
	case ${module_file} in */any-*.${EXT}) needed="y" && continue;; esac
	case ${module_file} in */archlive.sqfs) needed="y" && continue;; esac
	module_name=$(basename ${module_file} .${EXT})
	if [ "${arch}" = "dul" ]; then
		module_name=${module_name//i686-}
		module_name=${module_name//x86_64-}
	else
		module_name=${module_name//${arch}-}
	fi
	case $MODULES in *${module_name}*) needed="y" && continue;; esac
	case $EXTRAMODULES in *${module_name}*) needed="y" && continue;; esac
	if [ "$needed" = "n" ]; then
		warn "$module_file未在${CONFIG_FILE}中定义，移除到${NO_NEED_MODULES_DIR}下" | tee -a ${LOG}
		mv -f $module_file ${NO_NEED_MODULES_DIR}/
	fi
   done
   green "清理模块完成! " | tee -a ${LOG}

   # 拷贝附加程序模块
   if [ -d $EXTRAPACKAGEDIR ]; then
	[ ! -d ${EXTRA_PACKAGE_TARGET} ] && mkdir -p ${EXTRA_PACKAGE_TARGET}
   	for mod in $EXTRAPACKAGEDIR/*.$EXT; do
		msg2 -n "拷贝附加程序模块 $mod ..." | tee -a ${LOG}
		cp $mod ${EXTRA_PACKAGE_TARGET}/
	done
	green "完成!" | tee -a ${LOG}
   fi

   msg2 -n "整理软件清单放到镜像目录中..." | tee -a ${LOG}
   # ${CDNAME}.list 为默认启动标的  如果删除系统无法启动
   FINAL_LIST="${IMGROOT}/${CDNAME}/${CDNAME}.list"
   [ -f ${FINAL_LIST} ] && rm -f ${FINAL_LIST}

   if [ "$arch" = "dul" ]; then
	arches="i686 x86_64"
   else
	arches="$arch"
   fi
   for i in $arches; do
	[ -f ${WORK_DIR}/$i-packages.list ] && rm -f ${WORK_DIR}/$i-packages.list
	if [ -f ${PACKLIST}/$i-updated.list ]; then
		cp -f ${PACKLIST}/$i-updated.list ${IMGROOT}/${CDNAME}/
	elif [ -f ${IMGROOT}/${CDNAME}/$i-updated.list ]; then
		rm -f ${IMGROOT}/${CDNAME}/$i-updated.list
	fi
	for mod in ${MODULES}; do
		echo "模块 ${mod} 包含: " >>${WORK_DIR}/$i-packages.list
		echo "----------------------------------------" >>${WORK_DIR}/$i-packages.list
		cat ${PACKLIST}/${i}-mod_${mod}.new | sort >>${WORK_DIR}/$i-packages.list
		echo >>${WORK_DIR}/$i-packages.list
	done
   done

   echo "########################################" >>${FINAL_LIST}
   echo "#    ${CDNAME} 软件清单 ($arch)      #" >>${FINAL_LIST}
   echo "########################################" >>${FINAL_LIST}
   echo "${CDNAME} 最后更新于 $(date +%T" "%F)" >>${FINAL_LIST}
   echo >> ${FINAL_LIST}

   if [ "$arch" = "dul" ]; then
	echo "i686 & x86_64 双模式 软件清单" >> ${FINAL_LIST}
	echo >> ${FINAL_LIST}
	echo "i686 部分软件清单：" >> ${FINAL_LIST}
	echo "====================" >> ${FINAL_LIST}
	cat ${WORK_DIR}/i686-packages.list | sort >> ${FINAL_LIST}
	echo >> ${FINAL_LIST}
	echo "x86_64 部分软件清单：" >> ${FINAL_LIST}
	echo "====================" >> ${FINAL_LIST}
	cat ${WORK_DIR}/x86_64-packages.list >> ${FINAL_LIST}
   else
	cat ${WORK_DIR}/$arch-packages.list >> ${FINAL_LIST}
   fi
   green "完成!" | tee -a ${LOG}

   msg2 "准备启动文件..." | tee -a ${LOG}

    # 双模式默认在i686模块中查找启动文件
   case $arch in i686|x86_64) MODULEDIR="${WORK_DIR}/${ARCH}-modules" ;;
			dul) MODULEDIR="${WORK_DIR}/i686-modules" ;;
			esac
   bootflags=""
   if [ "$BOOT" = "grub" -o "$BOOT" = "grub-gfx" ]; then
	[ ! -d "${IMGROOT}/boot/grub" ] && mkdir -p "${IMGROOT}/boot/grub"
	bootfile=$(find $MODULEDIR -type f -name "stage2_eltorito")
	if [ ! "x${bootfile}" = "x" ]; then
		cp -f ${bootfile} ${IMGROOT}/boot/grub/
		green "找到引导程序 ${bootfile}，使用该引导程序覆盖 cd-root 里可能已经存在的引导程序." | tee -a ${LOG}
	else
		if [ -f ${IMGROOT}/boot/grub/stage2_eltorito ]; then
			error "目标系统中没有安装$BOOT，使用cd-root中原来的引导程序..." | tee -a ${LOG}
		else
			warn "目标系统中没有选择安装$BOOT, 在宿主系统中查找..." | tee -a ${LOG}
			grub --help 2>&1 >/dev/null
			if [ $? -ne 0 ]; then
				error "宿主系统也不存在$BOOT. 无法继续!请选择其他引导程序或者安装$BOOT..." | tee -a ${LOG}
				usage 1
			fi
			bootfile=$(find $MODULEDIR -type f -name "stage2_eltorito")
			if [ ! "x${bootfile}" = "x" ]; then
				cp -f ${bootfile} ${IMGROOT}/boot/grub/
				green "在 ${bootfile_dir} 目录下找到引导程序." | tee -a ${LOG}
			else 
				error "宿主系统也没有安装 $BOOT. 无法继续!请选择其他引导程序或者安装$BOOT..." | tee -a ${LOG}
				usage1
			fi
		fi
	fi
	bootflags="-b boot/grub/stage2_eltorito"
	green "引导程序 $BOOT 准备完毕." | tee -a ${LOG}
   fi

   if [ "$BOOT" = "syslinux" -o "$BOOT" = "isolinux" ]; then
	export bootfile_dir
	export target_bootfile_dir
	target_bootfile_dir=${IMGROOT}/isolinux
	[ ! -d ${target_bootfile_dir} ] && mkdir -p ${target_bootfile_dir}

	# 双模式下也采用i686系统中的syslinux来启动
	bootfile_dir="$(dirname $(find $MODULEDIR -type f -name "isolinux.bin"))"

	# 优先使用目标系统的最新版syslinux， 其次使用 cd-root提供的  再次宿主系统提供
	if [ -f ${bootfile_dir}/isolinux.bin ]; then
		cp -f ${bootfile_dir}/*.* ${target_bootfile_dir}/
	elif [ ! -f ${target_bootfile_dir}/isolinux.bin ]; then
		if [ -f ${IMGROOT}/syslinux/isolinux.bin ]; then
			bootfile_dir=${IMGROOT}/syslinux
			cp -f ${bootfile_dir}/*.* ${target_bootfile_dir}/
		else
			warn "目标系统和 ${IMGROOT} 下都没有 syslinux 启动文件，现在从宿主系统查找..." | tee -a ${LOG}
			bootfile_dir=$(dirname $(find /usr -type f -name "isolinux.bin"))
			if [ -f ${bootfile_dir}/isolinux.bin ]; then
				cp -f ${bootfile_dir}/*.* ${target_bootfile_dir}/
			else
				error "宿主系统也不存在 syslinux. 无法继续，请选择其他启动程序或者安装$BOOT..." | tee -a ${LOG}
				usage 1
			fi
		fi
	else
		bootfile_dir=${IMGROOT}/isolinux
	fi
	green "在 ${bootfile_dir} 下找到 syslinux 启动程序." | tee -a ${LOG}
	bootflags="-b isolinux/isolinux.bin -c isolinux/boot.cat"
	[ ! -f ${IMGROOT}/isolinux/isolinux.cfg ] && error "不存在启动配置文件isolinux.cfg" && exit 1
	# isolinux.cfg 在准备的时候从profile目录下cd-root对应目录中复制
	green "引导程序 $BOOT 准备完毕." | tee -a ${LOG}
   fi

   if [ "$BOOT" = "grub2" ]; then
	[ ! -d ${IMGROOT}/boot/grub ] && mkdir -p ${IMGROOT}/boot/grub
	grub2_mkimg=$(find $MODULEDIR -type f -name "grub-mkimage")
	if [ "x${grub2_mkimg}" = "x" ]; then
		if [ ! -x /bin/grub-mkimage ]; then
			error "目标系统及宿主系统中都没有安装grub2，\n 宿主系统安装grub2后再 sudo \
				sh ./$APPNAME img 工作目录 来重新制作镜像。" | tee -a ${LOG}
			usage 1
		fi
		grub2_mkimg="/bin/grub-mkimage"
		cp -f /usr/lib/grub/i386-pc/* ${IMGROOT}/boot/grub/
		cp -f /usr/share/grub/* ${IMGROOT}/boot/grub/
	else
		cp -f $(find $MODULEDIR -type d -name "i386-pc")/* ${IMGROOT}/boot/grub/
		cp -f $(find $MODULEDIR -type f -name "*.pf2") ${IMGROOT}/boot/grub/
	fi
	${grub2_mkimg} -d ${IMGROOT}/boot/grub/ -o core.img biosdisk pc gpt iso9660 fat ntfs ext2 pxe\
		reiserfs gfxterm ntfs
	cat ${IMGROOT}/boot/grub/{cdboot.img,core.img} > ${IMGROOT}/boot/grub/grub2cd.bin
	bootflags="-b boot/grub/grub2cd.bin"
	green "引导程序 $BOOT 准备完毕." | tee -a ${LOG}
   fi

   if [ "$IMG_TYPE" = "iso" ]; then
        msg2 "基于目录 ${IMGROOT} 使用 mkisofs v${mkisofs_version} 来创建 ISO 镜像，请稍后..." | tee -a ${LOG}
        qflag=""
        [ "${QUIET}" = "y" ] && qflag="-quiet"
        mkisofs ${qflag} -J -R -D -r -l $bootflags -uid 0 -gid 0 \
		-udf \
		-allow-limited-size \
		-input-charset utf-8 -p "${AUTHOR}" \
            -no-emul-boot -boot-load-size 4 -boot-info-table \
            -publisher "${PUBLISHER}" -log-file /tmp/archlive_img.log \
            -A "${CDNAME}" -V "${CDNAME}" \
            -o "${IMGNAME}" "${IMGROOT}"
        if [ $? -eq 0 ]; then
		./lib/bin/isohybrid "${IMGNAME}" 2>&1 >>${LOG}
		md5sum "${IMGNAME}" > "${IMGNAME}".md5
		iso_size=$(isosize ${IMGNAME} 2>/dev/null)
		if [ "x${iso_size}" = "x" ]; then
			iso_size=$(grep " MB" /tmp/archlive_img.log | sed 's|.*(\(.*cat ${PKGFILE} | sort > ${IMGROOT}/${CDNAME}/${CDNAME}.listMB\))|\1|')
		fi 
		cat /tmp/archlive_img.log >>${LOG}
		rm -f /tmp/archlive_img.log
		green "${IMGNAME}制作成功，大小 ${iso_size}。" | tee -a ${LOG}
        fi
   fi
}
